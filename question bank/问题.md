# .net

>修饰词 static、private、protect、final、transient、readonly 、internal、volatile

>static、private等用法

>volatile原理

    volatile实现变量的可见性，不保证变量的原子性。
    原理：锁缓存区或者总线，在对volatile修饰的变量进行修改的时候，直接把修改结果写入内存中，
    所有缓存区中对于该变量的缓存都失效。这样就保证获取到的volatile变量的值都是最新的值。
>集合 List<T> ArrayList Dictionary HasSet 线程安全类(ConcurrentQueue等集合) 以及原理

>string字符串连接，+、concat、string.Format()、StringBuilder

>happens-before规则
# 设计模式
>用到了哪些，具体场景

    工厂模式、建造者模式（quartz）

>单例模式

    饿汉式单例模式
    懒汉式单例模式
    双检锁单例模式
    用intelock实现
# 多线程和并发类的相关知识

>多线程有什么用，优缺点。

    优点:
    (1)充分利用多核cpu资源

    (2)防止阻塞，
    当有多个任务时，用多线程可以避免某个任务异常时阻塞所有任务
    分时操作系统和实时操作系统，时间片

    缺点:
    (1) 使用不当反而会影响效率 
    当cpu是单核的时候，多个线程工作会频繁上下文切换。
    即便是多核cpu，线程太多也会频繁的上下文切换，这样反而会导致效率变慢。

    解决方案:线程池、Task
    (2) 如果某些资源是线程共享的，需要考虑线程安全问题
    解决方案：加锁,线程安全类，Intelock，Actor模型

>创建线程方式

    Thread类和ThreadStart类
    ThreadPool.QueueUserWorkItem

>线程优先级

    Highest
    AboveNormal
    Normal
    BelowNormal
    Lowest
    

>什么是线程安全

    如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。



>线程同步

    线程同步主要解决线程安全问题和速率限制。
    1、原子操作 Interlocked;
    2、Monitor
    3、lock():lock语句其实是Monitor的封装。
    4、cas+自旋
    5、ReaderWriterLock，这个主要用户读取频繁的时候。
    6、事件
        1）AutoResetEvent（自动重置事件）
        2）ManualResetEvent（手动重置事件）
    7、信号量Semaphore
        信号量可以用在tcp中，限制链接数量。
    8、互斥体Mutex

>什么是原子操作

>什么是自旋

>什么是cas(compare and swap)

    cas是原子操作

>获取线程dump文件

>为什么创建和销毁线程会开销很大

    1、线程内核对象
    2、线程环境块
    3、用户模式栈
    4、内核模式栈
    5、DLL线程连接和线程分离通知

>什么是上下文切换、跨核上下文切换

    windows的cpu（或者说内核）一个时间片只能分配给一个线程，时间片到期时，windows就把上下文切换到另一个线程。这个过程就是线程调度。期间发生发生如下事情。

    1、将cpu寄存器中的值保存到当前正在运行的线程的内核对象内部的一个上下文机构中。

    2、从现有线程集合中选出一个线程供调度。如果该线程由另一个进程拥有，windows在开始执行任务代码或接触任何数据之前，还必须要切换cpu"看见"的虚拟地址空间
    
    3、将所选线程的上下文结构中的值加载到cpu的寄存器中。
    
    4、新线程在高速缓存区可能没有数据，还需要访问RAM来填充高速缓存区，以恢复高速执行状态。

    跨核上下文切换代价更昂贵


>如果减少上下文切换

    windows在一下情况下会进行上下文切换

    1、时间片结束，下个时间片cpu分配的线程不是当前线程的时候，会进行上下文切换

    2、线程阻塞(锁、睡眠等)，重新调度线程，把cpu资源分配给其他线程。

    第一种情况开发者是无法干涉的，所以要从第二种情况入手，减少线程的阻塞。

    无锁并发编程：actor模型
    原子操作:Interlock相关类
    CAS算法:CAS算法加自旋操作
    协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换（个人理解，类似.NET Task类）



>什么是乐观锁和悲观锁

>Semaphore



>Thread.sleep(0)

    线程会进入阻塞队列，引发线程调度，可能会产生上下文切换开销，然后再回到就绪队列。
    也可以通过该方法，避免权重高的线程一直占用cpu资源，把资源分配给权重低的线程。

>线程调度算法

    抢占式



>线程间共享数据

>线程间通讯

>一个线程出现异常

    这种情况下，线程的异常是无法在主线程中捕获的，所以需要在线程内部捕获，否则会发生未捕获异常，程序就会蹦掉。

    用Task的情况向，await关键字 wait()、waitall()方法还有Result属性都是会把异常抛出到主线程中。只要在这些代码块中try{}catch{}就行了

>生产者消费者模型的作用是什么

    这个问题很理论，但是很重要：

    （1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用

    （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约

>为什么使用线程池、线程池原理

    线程的创建和销毁是很耗费资源的，避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目;

>Task和线程池

>ReadWriteLock

>编程写一个会导致死锁的程序



>Task.Run和Task.Factory.StartNew

>Parallel进行并行计算
```csharp
List<int> list = new List<int> {  2, 3 ,4};
int result = list.AsParallel().Aggregate((i, j) =>
{
    return i+j;
});
object mutex = new object();
int sum = 1;
Parallel.ForEach(list,()=>1,
(item,state,localvalue) =>
{
    return item * localvalue;
},
localvalue => {
    lock (mutex)
    {
        sum=sum*i;
    }
});
```
**个人理解Parallel.ForEach**:

localvalue是计算结果，有可能多个任务分到同一个线程里，比如2,3分到一个线程里，
则会先处理2，此时localvalue为初始值1，计算完成后localvalue=item * localvalue=2;此时的localvalue
再传递到3的计算任务中，计算完成后localvalue=item * localvalue=6;这时的localvalue传递到第三个回调函数中
，计算后把值赋值给了sum。而值为4的任务在另一个线程里，这时候的localvalue为初始值1，重复刚才的过程，
最后又到第三个回调函数中，计算后把值赋值给sum
# 框架
>mvc

>ef dapper

>quartz

>polly


>日志(nlog、log4net)和日志门面接口

# 垃圾回收
>gc 垃圾回收算法

>类加载机制

>出现内存问题时定位方式

>idispose、析构方法close方法
#数据库
>sql server 编译、重编译、执行计划

>基本数据类型

>索引机制、几种索引和区别

>引擎

>锁机制

>慢sql定位和优化

>索引的原理

>union 和union all区别，lef join，not exists

# 缓存机制
>缓存加载

>缓存击穿、缓存雪崩、缓存穿透原因和相应解决方案

>redis原理和高级功能

>redis集群原理

# 分布式
>cap理论

>数据一致性的几种解决方案

>分布式事务

>分布式锁的实现

>分库分表

>分布式session的实现

# web
>get和post的区别

>转发与重定向的区别

>跨域问题如何解决

>如何保证接口的幂等性

>Session和Cookie的区别和联系以及Session的实现原理

>[http实时数据获取（短轮询、长轮询、websocket）](https://www.cnblogs.com/xrq730/p/9280404.html)
# 网络
>tcp/ip五元组

五元组：源IP地址、目的IP地址、协议号、源端口、目的端口

>三次握手和四次握手

>全连接队列和半连接队列

>发送队列和接受队列

>socket阻塞发送和接收(SocketFlags)

    发送数据时，如果发送队列满，发送方法会阻塞；如果服务端接收队列满，tcp底层不会把发送队列中的数据发送过去。
    接收数据时，如果用户buffer大于接收队列，如果设置flags为MSG_WAITALL（.NET socket估计是默认设置为MSG_WAITALL，因为在SocketFlags中没有看到WAITALL状态。），则会把用户buffer填满，接收方法才会返回。
>socket的Close()操作的行为（LingerOption）

|enable|seconds|行为
|--|--|--|
|false （禁用），默认值|不适用，超时值 （默认值）|尝试发送挂起数据的面向连接的套接字 (例如 TCP) 直到默认 IP 协议超时过期。
|true （已启用）|非零值超时|尝试发送挂起的数据，直到指定的超时时间已到，如果该尝试失败，然后 Winsock 重置连接。
|true （已启用）|零个超时时间。|将放弃所有挂起的数据。 对于面向连接的套接字 (例如 TCP)，Winsock 重置连接。

当LingerTime属性存储在LingerState属性设置为大于默认 IP 协议超时时间，则默认 IP 协议超时时间仍将应用，并替代

>tcp滑动窗口

>Nagle算法。

>多路复用iocp（SocketAsyncEventArgs）

>负载均衡算法


# 中间件

>mq的作用和使用场景

>服务化治理框架的作用和使用场景

>配置中心的作用和使用场景

>zookeeper的作用和使用场景

# 数据结构

>数据、链表、栈、队列、树等优缺点，在什么场景下使用什么数据结构

>二叉查找树、什么是平衡树，AVL树和红黑树的区别
