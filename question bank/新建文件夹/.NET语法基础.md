>3.1.7 类型初始化器何时调用。

>Finalize()、Dispose(bool disposing)和Dispose()方法。

    托管资源是可以被垃圾回收器进行回收的，所以如果类中只有托管资源，上面几个方法都可以不手动实现。
    Dispose()方法是IDisposeable接口的一个方法，可以用来手动释放托管资源和非托管资源。
    Finalize()方法是Dispose()方法的一个后置保障，确保在Dispose()方法没有被调用的时候，可以由垃圾回收器调用Finalize()方法来实现非托管资源的回收。所以Finalize()方法主要是回收非托管资源的。
    但是Finalize()方法的执行会由几个步骤，所以对性能是有影响的。
    也可以通过使用安全句柄来进行非托管资源的回收，安全句柄的回收方法会在垃圾回收时被clr调用。
    Dispose(bool disposing)是一种设计模式。
    Dispose方法中调用Dispose(true);会把托管资源和非托管资源一起回收，然后调用GC.SupressFinalize()告诉垃圾回收器已释放资源，不用调用Finalize()；
    Finalize方法中调用Dispose(false);会释放未被安全句柄包装的非托管资源。

    简单总结：
    
    非托管资源的释放有两种模式：Finalize和安全句柄。Finalize方法比较耗性能。
    而Dispose方法是提供一个接口给程序员，用来手动释放资源。
    Dispose(bool disposing)是一种设计模式。
    
以下是一个常规模式，用于实现使用安全句柄的基类的释放模式：
```csharp
using Microsoft.Win32.SafeHandles;
using System;
using System.Runtime.InteropServices;

class BaseClass : IDisposable
{
   // Flag: Has Dispose already been called?
   bool disposed = false;
   // Instantiate a SafeHandle instance.
   SafeHandle handle = new SafeFileHandle(IntPtr.Zero, true);
   
   // Public implementation of Dispose pattern callable by consumers.
   public void Dispose()
   { 
      Dispose(true);
      GC.SuppressFinalize(this);           
   }
   
   // Protected implementation of Dispose pattern.
   protected virtual void Dispose(bool disposing)
   {
      if (disposed)
         return; 
      
      if (disposing) {
         handle.Dispose();
         // Free any other managed objects here.
         //
      }
      
      disposed = true;
   }
}
```

以下是一个常规模式，用于实现重写 Object.Finalize 的基类的释放模式。
```csharp
using System;

class BaseClass : IDisposable
{
   // Flag: Has Dispose already been called?
   bool disposed = false;
   
   // Public implementation of Dispose pattern callable by consumers.
   public void Dispose()
   { 
      Dispose(true);
      GC.SuppressFinalize(this);           
   }
   
   // Protected implementation of Dispose pattern.
   protected virtual void Dispose(bool disposing)
   {
      if (disposed)
         return; 
      
      if (disposing) {
         // Free any other managed objects here.
         //
      }
      
      // Free any unmanaged objects here.
      //
      disposed = true;
   }

   ~BaseClass()
   {
      Dispose(false);
   }
}
```

以下是一个常规模式，用于实现使用安全句柄的派生类的释放模式：
```csharp
using Microsoft.Win32.SafeHandles;
using System;
using System.Runtime.InteropServices;

class DerivedClass : BaseClass
{
   // Flag: Has Dispose already been called?
   bool disposed = false;
   // Instantiate a SafeHandle instance.
   SafeHandle handle = new SafeFileHandle(IntPtr.Zero, true);

   // Protected implementation of Dispose pattern.
   protected override void Dispose(bool disposing)
   {
      if (disposed)
         return; 
      
      if (disposing) {
         handle.Dispose();
         // Free any other managed objects here.
         //
      }
      
      // Free any unmanaged objects here.
      //

      disposed = true;
      // Call base class implementation.
      base.Dispose(disposing);
   }
}
```
以下是一个常规模式，用于实现重写 Object.Finalize 的派生类的释放模式：
```csharp
using System;

class DerivedClass : BaseClass
{
   // Flag: Has Dispose already been called?
   bool disposed = false;
   
   // Protected implementation of Dispose pattern.
   protected override void Dispose(bool disposing)
   {
      if (disposed)
         return; 
      
      if (disposing) {
         // Free any other managed objects here.
         //
      }
      
      // Free any unmanaged objects here.
      //
      disposed = true;
      
      // Call the base class implementation.
      base.Dispose(disposing);
   }

   ~DerivedClass()
   {
      Dispose(false);
   }
}
```


>重写了Equals方法为什么还要重写GetHashCode方法。

    为了保持一个原则：Equals相等的对象HashCode也相等。
    
>接口返回值为什么要禁止使用枚举类型。

>