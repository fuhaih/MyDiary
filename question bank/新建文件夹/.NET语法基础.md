>.Net中所有内建类型的基类是什么

    System.Object是.NET中所有内建类型的基类

>System.Object包含哪些方法，哪些是虚方法

    虚方法 virtual修饰的方法，表示该方法可以复写
    静态Equals()
    实例 Equals() 虚方法
    ToString() 虚方法
    GetHashCode() 虚方法
    GetType() 
    ReferenceEquas()
    MenberwiseClone()
    Finalize()

>值类型和引用类型的区别
    
    继承：
    值类型是继承自System.ValueType，System.ValueType是继承自System.Object，引用类型是继承自System.Object
    存储：
    值类型是在内存堆栈中分配内存，引用类型是在堆中分配内存（字段所需内存、同步块索引、类型对象指针），栈中存储的是变量名和引用类型的引用地址。值类型在进行装箱操作的时候会把值复制到堆中，并创建堆对象需要的同步块索引和类型对象指针。
    赋值：
    值类型的赋值会产生一个数据副本，引用类型赋值同样会产生一个副本，不过存储的值是一个引用地址。
    同步块索引：
    同步块索引是用来进行lock操作的，在进行lock操作的时候需要添加一个锁对象 lock（object），所以值类型是不能作为锁对象的，因为值类型没有同步块索引。

>简述装箱和拆箱的原理

    装箱：这个行为只有值类型会发生，值类型转换为引用类型（通常是转换为System.Object,也可能是其他类型。）的过程称为装箱，当发生装箱操作时，值类型的值会复制一份到堆中，并给其添加上堆对象都有的类型对象指针和同步块索引，而在栈中会存放有变量名和对堆中副本的引用。频繁地装箱会比较耗时。

    拆箱：拆箱过程正好相反，拆箱还会有一个判断类型的操作，如果类型不对，会抛出异常。

    装箱和拆箱都需要在堆中进行操作，所以都会对性能有影响，并且可能引发垃圾回收

>如何减少装箱拆箱

    当有Object类型参数的重载方法时需要注意
    如String.Concat(string s1,string s2); string.Concat(object obj1,object obj2);
    这时候传参时需要把值类型转换为string类型再进行传参，否则会调用object类型参数的方法；
    字符串的+操作符就是使用的String.Concat(string s1,string s2)，变量超过四个时使用的是String.Concat(T[]),其内部是使用的StringBuilder
    类似的方法还有String.Format();

>c#有没有全局变量

    没有传统意义上的全局变量，因为c#是面向对象语言，所有对象都是属于某一个类型，但是可以通过静态字段来实现变量的全局可见。

>struct和class的区别，struct适用于哪些场合

    struct不支持继承（除了默认继承自System.ValueType）。
    struct不能自定义无参构造函数
    struct成员不能在定义时进行初始化。
    struct是定义的值类型，内存在栈中分配，但是栈中空间有限，所以不适合定义比较复杂的类型。
    class是定义的引用类型。

>3.1.7 类型初始化器何时调用

>c#中参数有几种传递方式

    两种，值传递和引用传递
    默认是值传递，ref、out修饰是引用传递，out要求参数在方法返回前进行赋值。还有个params可以修饰参数，params实现可变参数。

>c#中string和String有什么区别

    没有区别，string是c#的一个关键字，同时也是String类型的别名，所以在使用上是没有什么区别的。

>.NET支持哪几种可访问性级别，c#实现了几种

    .NET支持的可访问性有 publish、family、assembly、family&assembly、family or assembly、private
    c#支持的可访问性有publish、protected、private、internal、protected internal

>简述属性的特点，属性和方法的异同。

    属性给字段提供get/set访问器，在外部使用时会跟字段操作差不多，比较简洁
    属性其实是一个语法糖，在编译完成后会生成get和set方法，所以和方法相比并无什么区别，可以使用virtual修饰，也可以在interface中进行定义。
    c#中还可以使用自动化属性，定义自动化属性后不用额外写对象字段，编译后会自动生成对应字段和get/set方法。

>简述c#中的浅赋值和深赋值

    浅拷贝只是拷贝了值类型字段的值和引用类型字段的引用，引用类型字段引用的值并没有被拷贝。
    深拷贝就是拷贝完整个值副本，包括引用类型字段所引用的值。
    拷贝只是对于非静态字段来说的，静态字段无需拷贝。