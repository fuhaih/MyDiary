>.Net中所有内建类型的基类是什么

    System.Object是.NET中所有内建类型的基类

>System.Object包含哪些方法，哪些是虚方法

    虚方法 virtual修饰的方法，表示该方法可以复写
    静态Equals()
    实例 Equals() 虚方法
    ToString() 虚方法
    GetHashCode() 虚方法
    GetType() 
    ReferenceEquas()
    MenberwiseClone()
    Finalize()

>值类型和引用类型的区别
    
    继承：
    值类型是继承自System.ValueType，System.ValueType是继承自System.Object，引用类型是继承自System.Object
    存储：
    值类型是在内存堆栈中分配内存，引用类型是在堆中分配内存（字段所需内存、同步块索引、类型对象指针），栈中存储的是变量名和引用类型的引用地址。值类型在进行装箱操作的时候会把值复制到堆中，并创建堆对象需要的同步块索引和类型对象指针。
    赋值：
    值类型的赋值会产生一个数据副本，引用类型赋值同样会产生一个副本，不过存储的值是一个引用地址。
    同步块索引：
    同步块索引是用来进行lock操作的，在进行lock操作的时候需要添加一个锁对象 lock（object），所以值类型是不能作为锁对象的，因为值类型没有同步块索引。

>简述装箱和拆箱的原理

    装箱：这个行为只有值类型会发生，值类型转换为引用类型（通常是转换为System.Object,也可能是其他类型。）的过程称为装箱，当发生装箱操作时，值类型的值会复制一份到堆中，并给其添加上堆对象都有的类型对象指针和同步块索引，而在栈中会存放有变量名和对堆中副本的引用。频繁地装箱会比较耗时。

    拆箱：拆箱过程正好相反，拆箱还会有一个判断类型的操作，如果类型不对，会抛出异常。

    装箱和拆箱都需要在堆中进行操作，所以都会对性能有影响，并且可能引发垃圾回收

>如何减少装箱拆箱

    当有Object类型参数的重载方法时需要注意
    如String.Concat(string s1,string s2); string.Concat(object obj1,object obj2);
    这时候传参时需要把值类型转换为string类型再进行传参，否则会调用object类型参数的方法；
    字符串的+操作符就是使用的String.Concat(string s1,string s2)，变量超过四个时使用的是String.Concat(T[]),其内部是使用的StringBuilder
    类似的方法还有String.Format();

>c#有没有全局变量

    没有传统意义上的全局变量，因为c#是面向对象语言，所有对象都是属于某一个类型，但是可以通过静态字段来实现变量的全局可见。

>struct和class的区别，struct适用于哪些场合

    struct不支持继承（除了默认继承自System.ValueType）。
    struct不能自定义无参构造函数
    struct成员不能在定义时进行初始化。
    struct是定义的值类型，内存在栈中分配，但是栈中空间有限，所以不适合定义比较复杂的类型。
    class是定义的引用类型。
