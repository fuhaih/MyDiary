# dotnet

## clr

>字符串优化

当处理大量字符串数据，并且数据有很多重复值时，可以使用字符串常驻池来优化，也可以自己写字典来存储优化

## 多线程

>task&thread

>锁

>线程安全类



>Semaphore


## framework

## core

## 库


> swagger

> nlog

> quartz

> ef

## winform

dev

## wpf



# 数据库

## sql server

>sql



* in、not in

* exists 、not exists

这两个为bool布尔类型判断

>登录名、用户名、角色、权限

>索引

[索引设计](https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2008/cc280372(v=sql.100))

* 聚集索引

* 非聚集索引

* 筛选索引

[filter indexs](https://docs.microsoft.com/zh-cn/sql/relational-databases/indexes/create-filtered-indexes?view=sql-server-ver15)

>事务级别

死锁

>统计信息

SQLServer中，在执行一个批处理语句时，关系引擎中的查询优化器会先估计生成较优的执行计划，执行执行器才安照此执行计划请求数据。即在生成执行计划期间，sqlserver是根据表中的统计信息进行行数估计，按照脚本语义来确定物理操作步骤生成执行计划，再按照该执行计划访问数据。而对于数据较大的表，按照统计信息估计的行数也常常不准确，这就是使查询使用了不准确的执行计划而比较慢。类似如：“参数嗅探”因传递参数值无法确定而估算错误；使用表变量不会有统计信息也不会估算行数。



>执行计划

>数据库优化

在查询分析阶段，查询优化器查看查询的每个阶段并决定限制需要扫描的数据量是否有用。如果一个阶段可以被用作一个扫描参数(SARG)，那么就称之为可优化的，并且可以利用索引快速获得所需数据。

如果一个表达式不能满足SARG的形式，那它就无法限制搜索的范围了

sql server中会进行查询优化，当数据库小的时候，可能会判断全表扫描会比走索引效率高，所以会直接全表扫描，查询优化器是会根据统计信息进行查询优化，选择是否使用索引或者使用那个索引。

* 命中聚集索引，根据需求添加非聚集索引

* 避免使用like查询

尽量使用精准的值和值域进行比较

* 索引字段非空，如果索引字段可以为空，在判空时会不走索引

这个在sql server中是可以命中索引的，具体要看数据库中的索引实现

*尽量使用正逻辑而不是使用非逻辑， <> 和!=操作，这样的操作不会走索引

比如字符串索引树大概是这样

            a
        ab      ac
    abd      acg  acp

找字段等于acp时，根据树先找第一个字母a，再找ac，再找到acp，不用遍历所有的字符串，这样的查找在字符串多的时候效率会比全部遍历很有优势

那如果是找不等于<>，那这样是没办法使用索引树的，树的所有节点都需要全部遍历。

索引的性质导致非逻辑会不走索引，不过is not null除外，is not null需要先搞清楚sql server 对null的存储结构。


* or、in使用不当

使用or操作符是，需要注意多个条件中是否都命中索引，如果有条件不命中索引，会全表扫描

in操作也是要注意索引的应用，in操作也是可以命中索引的，但是in最好不要太多值

in可以命中索引，但是not in是不能命中索引的，所以不要使用not int

* 函数使用

尽量避免查询条件中再字段上进行运算操作或者函数操作，这样也是不会命中索引的。

* count(*),count(1) 和count(col)

count()函数是判断不为空时就计数，所以传入*、1或者col都是可以的，传col会判断col是否为空，和*、1的含义不一样，根据需求来使用

* order 

order应该要按照索引来写order，能提高效率

* join

先筛选再join


>数据库内存吃满问题解决思路

## no sql

> redis

> mongodb




# 网络

## tcp

>Keepalive

tcp协议中并没有保活机制，也就是tcp进行三次握手连接后，就会一直都出于连接状态，直到进行四次挥手，才算是断开。在挥手之前，即便是网络断开了，tcp也并没有断开。

但是这样的机制会有弊端，一些因为网络或者其他问题，已经算是不能通讯的连接，会一直占用着资源，所以一般tcp的具体实现框架（dotnet的socket）都会实现Keepalive机制，如果客户端一段时间内(通常两小时，可以配置)没有发送数据过来，就是向客户端发送一个Keepalive包，接收到回复，就说明还在连接状态，否则就通知上层该连接已经不能通讯。

>Heart-beat

Heart-beat 和Keepalive类似，是一种保活机制，Keepalive是tcp实现的时候加入的机制，而Heart-beat一般是在业务层实现，也就是一般要自己实现。socket.io就是每个时间间隔都会发送一次Heart-beat包到服务器。

>滑动窗口

## socket （tcp实现）

>队列

每个socket tcp连接会有一个发送队列和接收队列，队列大小可以自己设置，当发送队列满的时候，send方法会异常

>文件发送

```csharp
Socket.SendFile
```

文件发送，一般经过以下步骤，从磁盘读取到缓冲区，缓冲区再读取到内存中，进行发送时候，把数据从内存中再写入网络io缓冲区，再缓冲区写入到网络io中

而SendFile是使用的零拷贝技术，省略了文件从缓冲区到内存的过程，直接从缓存区拷贝到网络io的缓冲区


如果用send方法，需要对较大的文件进行拆分发送，否则发送队列会满，导致发送异常，send由于比SendFile多两次拷贝，所以会比SendFile慢。

>iocp


## socket出现的一些异常情况

>close_wait

下面是c语音的情况
```
出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。
```

dotnet中也是如此，服务端在读或者写时，需要根据返回状态判断异常，及时关闭连接

>time_wait

主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度，MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。MSL在RFC 1122上建议是2分钟


四次挥手，客户端放发送fin，此时客户端处于fin_wait_2状态，服务端会返回ack，此时客户端会处于time_wait状态，fin_wait_2状态持续时间很短，因为ack确认不需要程序来完成，socket会自动完成，即便由于网络原因没有接收到ack确认，fin_wait_2状态也会很快转换为time_wait状态，再等待服务端close，如果服务器没有close，time_wait状态将会默认持续2分钟，在此期间内，如果客户端有大量socket close，那将会有大量连接处于time_wait状态，将会占用大量的端口

解决方法：

1、linux中maximum segment lifetime(最大分节生命期）是可以进行配置的，windows中好像配置不了，不过不太建议这么做，这个配置会涉及到很多东西。

2、良好的客户端和服务端实现，确保被动关闭方及时close，服务端最好不要主动进行关闭，服务端出现大量time_wait那影响更大，因为有时候服务端是没办法控制客户端行为的(有些项目对接，客户端是别人实现的)

3、对于同一个服务端，客户端最好不要有大量的连接的创建和关闭，创建连接耗时，如果服务端不友好，关闭连接时又会有time_wait等待，如果出现大量操作，将会占用大量端口，不仅影响当前程序使用，还会影响其他程序。



## http


# 网络安全

## 爬虫和seo

## xss攻击

>sql 注入

>js注入

## ssl中间人攻击

## 缓冲区溢出攻击

# 算法

## 效率

>时间复杂度

>空间复杂度

## 斐波拉契数列

>递归实现

```csharp
int Fib(int n)
{
    return n<2?1:(Fib(n-1)+Fib(n-2))
}
```

缺点：

递归会让栈太深，而且出现了重复计算，Fib(n-1) 如果n-1>2,那么Fib(n-1) = Fib(n-2)+Fib(n-3) ,Fib(n) = Fib(n-1) + Fib(n-2) =  Fib(n-2)+Fib(n-3) +  Fib(n-2)

如果n很大的话，重复的计算量将很大，栈的深度也会很深


>使用循环去递归

>数学方法

* 矩阵

* 通项公式

* 

# 设计模式

## 常用

>单例模式

多种实现

>工厂模式

一般工厂、抽象工厂

>builder模式

使用场景

# 前端

## html

## css

## js

## vue

# 中间件

## rabbitmq

## zookeeper

## redis

## nginx

# 安全

## 认证授权

## 权限管理

# 业务系统

## 单点登录

## 权限管理


# 分布式

## 分布式

>cap

## 集群

## 微服务



