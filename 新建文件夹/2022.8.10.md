
## nginx

>nginx servername

nginx 会根据servername来匹配，匹配不上的话默认选择第一个

比如配置了

80
servername test.domain.com

443
servername test.api.com

那么访问 https://test.domain.com 的时候，由于是https，会找监听了443端口的，而443端口上找不到servername为test.domain.com的配置，就会使用找到的第一个443端口，最终访问到的是第二个配置。


## ef core


ef core 跟踪和不跟踪的情况，可以查看[跟踪和不跟踪](https://docs.microsoft.com/en-us/ef/core/querying/tracking)

```csharp
_context.Blog.Select(m=>new {ID=m.ID,Name=m.Name,Content = m.Content})
```

上诉代码是不会跟踪对象的，但是返回值中有唯一键ID，可以通过Attach方法进行跟踪，并且默认会设置为Unchanged状态

所以Attach方法只需要调用一次，否则会重置为Unchanged状态

```csharp
var blog = _context.Blog.Select(m=>new {ID=m.ID,Name=m.Name,Content = m.Content}).FirstOrDefault();

_context.Blog.Attach(blog);

blog.Name = 'test_name';

_context.SaveChanges();

```
上述代码会把名称更新为`test_name`

```csharp
var blog = _context.Blog.Select(m=>new {ID=m.ID,Name=m.Name,Content = m.Content}).FirstOrDefault();

_context.Blog.Attach(blog);

blog.Name = 'test_name';

_context.Blog.Attach(blog);

blog.Content = "test_content";

_context.SaveChanges();

```

上述代码会原本把Name变更为`test_name`，但是再次调用`Attach`方法后，会重新置为`Unchanged`状态，就会认为Name字段没有变更，然后再变更Content为`test_content`,最终是只更新Content字段到数据库中。

## 编码

>gb2312

```csharp
Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
var encoding = Encoding.GetEncoding("gb2312");
```

dotnet的`Encoding`中有几个常用的编码格式，但是一些不常用的需要使用`CodePagesEncodingProvider`来获取，所以需要先注册`CodePagesEncodingProvider`对象

## ToString 方法

ToString方法可以进行格式化操作，详细看[format number](https://docs.microsoft.com/en-us/dotnet/standard/base-types/formatting-types)

这里说一个`G`格式,一个浮点数类型存储到数据库后，会在后面带有0,使用G格式化会清理掉没有用的0

``` csharp
decimal value = 23.501m;
//存储到数据库后,取出来会是类似下列的数值
decimal value = 23.5010000m;
//使用G格式化，后面数字代表位数
string result = value.ToString("G2");//23
string result = value.ToString("G3");//23.5
string result = value.ToString("G4");//23.5
string result = value.ToString("G5");//23.501
```

** sql server

>Group by 和 distinct 查询

这两个都可以进行去重操作，并且生成的执行计划是一样的，所以效率也是一样的

## IIS URL Rewrite

[官方文档](https://docs.microsoft.com/en-us/iis/extensions/url-rewrite-module/using-the-url-rewrite-module)

url rewrite比较经常配置的有三个地方

现有一http请求为`http://demo.com/test/add`

>匹配url

这里匹配的是域名后面的url `test/add`

选中与模式匹配，正则表达式，模式配置为`test/(.*)`

就会根据正则表达式来匹配url

|向后引用|值|含义|
|----|----|----|
|{R:0}|test/add|匹配到的第一个正则表达式分组，这里是整个模式匹配到的url|
|{R:1}|add|匹配的第二个正则表达式的分组，也就是第一个括号匹配到的内容|

>条件

|输入|值|
|----|----|
|{HTTPS}| 这个只有两个值，OFF 或者是ON,^OFF$表示是HTTP请求，^ON$表示是HTTPS请求
|{HTTP_HOST}|这个表示域名，可以通过这个来匹配域名是否符合自己的需求
|{QUERY_STRING}|这个是参数，可以通过这个匹配参数是否符合自己需求


例子:

|输入|类型|模式|
|----|----|----|
|{HTTPS}|与模式匹配|^OFF$|
|{HTTP_HOST}|与模式匹配|^demo\.com$

这里的配置就是匹配方法为http，域名为demo.com的请求

`|{HTTPS}|与模式匹配|^OFF$|`

这里的匹配结果是

|向后引用|值|含义|
|----|----|----|
|{C:0}|OFF|匹配到的第一个正则表达式分组，这里是{HTTPS}的值OFF|

其他几个条件的匹配结果也是通过C表示

>操作

```
操作类型：重定向

重定向url: https://{HTTP_HOST}/{R:1}

重定向类型：301
```
这里配置的重定向url

{HTTP_HOST}就是匹配到的域名demo.con

{R:1}就是匹配到的url的括号里的内容

最终就是跳转到`https://demo.com/add`

>反向代理

需要安装`Application Request Routing`

其他配置一样，在操作项中配置为重写