## EF方法扩展

>方法1

使用HasDbFunction来扩展
```csharp
public class MyDBContext : DbContext
{
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.HasDbFunction(IsNumericMethodInfo)
        .HasName("ISNUMERIC")
        .IsBuiltIn();
        base.OnModelCreating(modelBuilder);
    }

    private static readonly MethodInfo IsNumericMethodInfo = typeof(HDIS_DBContext)
        .GetRuntimeMethod(nameof(IsNumeric), new[] { typeof(string) });

    public bool IsNumeric(string s) => throw new NotSupportedException();
}
```

使用：

```csharp
MyDBContext context;

var query = context.Blogs.Where(m=>context.IsNumeric(m.CreateTime));

```

>方法2 

使用`IMemberTranslator`

```csharp
    public class DayOfWeekTranslator : IMemberTranslator
    {
        private readonly ISqlExpressionFactory _sqlExpressionFactory;
        public DayOfWeekTranslator(ISqlExpressionFactory sqlExpressionFactory)
        { 
            this._sqlExpressionFactory = sqlExpressionFactory;
        }

        public SqlExpression Translate(SqlExpression instance, MemberInfo member, Type returnType, IDiagnosticsLogger<DbLoggerCategory.Query> logger)
        {
            Type type = instance.GetType();
            if (member.DeclaringType == typeof(DateTime) && member.Name == "DayOfWeek")
            {
                var time = _sqlExpressionFactory.Constant(new DateTime(1753, 1, 7));
                var day = _sqlExpressionFactory.Function(
                    "DATEDIFF",
                    new[] { _sqlExpressionFactory.Fragment("DAY"), time, instance! },
                    nullable: true,
                    argumentsPropagateNullability: new[] { false, true },
                    typeof(int));
                var split = _sqlExpressionFactory.Constant(7);
                var dayOfWeek = _sqlExpressionFactory.Modulo(day, split);
                return dayOfWeek;
            }
                
            return null;
        }
    }
    public class DayOfWeekTranslatorPlugin : IMemberTranslatorPlugin
    {
        public IEnumerable<IMemberTranslator> Translators { get; }

        public DayOfWeekTranslatorPlugin(ISqlExpressionFactory sqlExpressionFactory)
        {
            var translators = new List<IMemberTranslator>();
            translators.Add(new DayOfWeekTranslator(sqlExpressionFactory));
            Translators = translators;
        }
    }
```
```csharp
    public class SqlServerDbContextOptionsExtension : IDbContextOptionsExtension
    {
        private DbContextOptionsExtensionInfo _info = null;
        public DbContextOptionsExtensionInfo Info
        { 
            get { return _info??new MyDbContextOptionsExtensionInfo(this); }
        }

        public void ApplyServices(IServiceCollection services)
        {
            services.AddSingleton<IMemberTranslatorPlugin, DayOfWeekTranslatorPlugin>();
            //services.AddSingleton<IQueryableMethodTranslatingExpressionVisitorFactory, CustomerSqlServerQueryableMethodTranslatingExpressionVisitorFactory>();
        }

        public void Validate(IDbContextOptions options)
        {
            
        }

        private class MyDbContextOptionsExtensionInfo : DbContextOptionsExtensionInfo
        {
            private readonly SqlServerDbContextOptionsExtension _extension;

            public override bool IsDatabaseProvider => false;

            private string? _logFragment;

            public override string LogFragment => _logFragment ??= CreateLogFragment();

            private string CreateLogFragment()
            {
                var sb = new StringBuilder();
                sb.Append("RowNumberSupport ");
                return sb.ToString();
            }

            public MyDbContextOptionsExtensionInfo(SqlServerDbContextOptionsExtension extension)
               : base(extension)
            {
                _extension = extension ?? throw new ArgumentNullException(nameof(extension));
            }

            public override void PopulateDebugInfo(IDictionary<string, string> debugInfo)
            {
                
            }

            public override long GetServiceProviderHashCode()
            {
                return 0;
            }
        }
    }
```

```csharp
    public static class SqlServerDbContextOptionsBuilderExtensions
    {
        public static SqlServerDbContextOptionsBuilder AddCustomSupport(
           this SqlServerDbContextOptionsBuilder sqlServerOptionsBuilder)
        {
            var infrastructure = (IRelationalDbContextOptionsBuilderInfrastructure)
                                 sqlServerOptionsBuilder;
            var builder = (IDbContextOptionsBuilderInfrastructure)
                              infrastructure.OptionsBuilder;

            // if the extension is registered already then we keep it 
            // otherwise we create a new one
            var extension = infrastructure.OptionsBuilder.Options
                                          .FindExtension<SqlServerDbContextOptionsExtension>()
                            ?? new SqlServerDbContextOptionsExtension();
            builder.AddOrUpdateExtension(extension);

            return sqlServerOptionsBuilder;
        }
    }

```

使用：
```csharp
    services.AddDbContext<HDIS_DBContext>(options => {
        options.UseSqlServer(connectionString,action=>action.AddCustomSupport());
    });

    var query = context.Blogs.Group(m=>m.CreateTime); 
```

## 异步操作是否会生成新的线程

异步应该是和完成端口的实现类似，其维护有一个完成队列和多个运行状态的线程(12个),由这些线程消费处理这些队列中的消息

正常情况下会一直使用这些线程处理消息，如果某个线程sleep之后，该线程就会进入等待状态，运行中的线程就是11个，其他线程也没有空闲的时候，在正在运行的线程数量不超过12的情况下，创建新的线程进行处理。

异步就是为了提高线程的使用率，避免重复创建和销毁线程，所以使用异步最好不要使用sleep等语句，避免重复创建线程。

使用sleep的情况下，会不断创建线程

线程还分任务线程(线程池)和io线程等，这个具体情况有待考量

```csharp
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i < 2000; i++)
            {
                Task.Run(async () =>
                {
                    await GetString();
                });
            }
            Console.ReadLine();
        }

        public static int counter = 0;

        static async Task<string> GetString()
        {
            var httpClient = new HttpClient();

            var str = await httpClient.GetStringAsync("http://cnblogs.com");

            Console.WriteLine($"counter={++counter}, 线程：{Thread.CurrentThread.ManagedThreadId},str.length={str.Length}");

            Thread.Sleep(1000000);

            return str;
        }
    }
```

使用while的情况下，当线程数量达到12的时候，如果这些线程还没处理完，新的任务就不会进来。
```csharp
    static async Task<string> GetString()
    {
        var httpClient = new HttpClient();

        var str = await httpClient.GetStringAsync("http://cnblogs.com");

        Console.WriteLine($"counter={++counter},时间:{DateTime.Now}, 线程：{Thread.CurrentThread.ManagedThreadId},str.length={str.Length}");

        while (true) { }

        return str;
    }
```