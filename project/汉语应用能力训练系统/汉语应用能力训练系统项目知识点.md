
## rabbitmq问题

>默认交换器

rabbitmq在安装完后会有一个默认的交换器，名字是空的，每个queue都会和该交换器有一个binding，bindingkey就是queuename;
该交换器是持久的，direct类型的。所以在使用简单的direct类型交换器可以直接用默认的；

```csharp
//申明一个队列，这时已经和默认交换器绑定了，bingdingkey就是队列名test
model.QueueDeclare("test", false, false, false, null);
byte[] data = Encoding.UTF8.GetBytes(teststr);
//在发布时，交换器名称为空，就会直接给默认交换器，然后bingdingkey为test，就直接把数据给队列test了。
model.BasicPublish("", "test", props, data);
```

>服务质量
```csharp
//参数
//prefetchSize:滑动窗口数量，消费端会根据 prefetchSize 的大小批量获取数据，比如说默认值是1000，那么消费者就会预先加载1000条数据到本地的内存中
//prefetchCount:允许最多prefetchCount个ack没确认（ack没确认表明消息没有消费完成），当prefetchCount为2时，也就是允许消费端同时消费两个消息；
//global：true\false 是否将上面设置应用于channel，简单点说，就是上面限制是channel级别的还是consumer级别
model.BasicQos(0, subscriber.PrefetchCount, false);
```
>消息多发（使用临时队列）

使用场景：消费端多发情况，也就是当某个消息是要发送到多个消费端的时候，

```csharp
//durable：true、false true：在服务器重启时，能够存活
//exclusive ：是否为当前连接的专用队列，在连接断开后，会自动删除该队列，生产环境中应该很少用到吧。
//autodelete：当没有任何消费者使用时，自动删除该队列。this means that the queue will be deleted when there are no more processes consuming messages from it.
var result = model.QueueDeclare("", true, true, true, null);
model.QueueBind(result.QueueName, "test", "test",null);

```
首先创建一个Fanout类型的交换器test，该交换器会把消息发送到所有绑定到该交换器上的队列

消费端创建一个空名称的队列，rabbitmq会自动生成一个类似amq.gen-JzTY20BRgKO-HjmUJj0wLg的队列名，然后后面各个参数为true，当消费端断开连接时，队列就会删除。

然后把新建的队列绑定到多发交换器test上。

当多个消费端连接时，就会生成多个队列，绑定到test，消息发送时就能实现多发。当有消费端断开时，对应的队列就会被删除。

## web api问题

> 常见的请求body类型

* application/x-www-form-urlencoded

格式：以`&`号连接多个参数
```
a=1&b=2
```

* application/json

普通json格式

* multipart/form-data

以boundary来划分多个数据。
```http
POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryRBSecJmkpXmr64GL

------WebKitFormBoundaryRBSecJmkpXmr64GL
Content-Disposition: form-data; name="id"

123
------WebKitFormBoundaryRBSecJmkpXmr64GL
Content-Disposition: form-data; name="text"

123
------WebKitFormBoundaryRBSecJmkpXmr64GL
Content-Disposition: form-data; name="files"; filename="edusoho.txt"
Content-Type: text/plain

data of file
------WebKitFormBoundaryRBSecJmkpXmr64GL--
```

请求头中设置`Content-Type`为`multipart/form-data`，后面带一个`boundary`，`boundary`可以自己定义



>[FromBody] [FromUri]误用

这两个特性不能用在默认数据格式中，是在使用一个复杂类来接收参数对象时使用的。

>httpclient 发送数据

* application/x-www-form-urlencoded  

这个是form表单的格式，以`&`号来连接各个参数，如`a=1&b=2`;

* application/json 

这个就是普通的json格式

* multipart/form-data

这个格式一般是用来传输文件的，同时也能传递其他参数。

**发送application/json格式数据**

```csharp
string reqUrl = "http://localhost:44837/api/source/test";
using (HttpClient client = new HttpClient(new HttpClientHandler() { UseCookies = false }))//若想手动设置Cookie则必须设置UseCookies = false
{
    //json格式
    HttpContent content = new StringContent("{\"id\":\"testid\",\"text\":\"text\"}");
    content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/json");
    var result = client.PostAsync(reqUrl, content).Result;
    try
    {
        if (result.IsSuccessStatusCode)
        {
            string rslt = result.Content.ReadAsStringAsync().Result;
            Console.WriteLine(rslt);
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
    finally
    {
        client.Dispose();
    }
}
```

**发送application/x-www-form-urlencoded格式数据**

FormUrlEncodedContent

```csharp

```

**发送multipart/form-data格式数据**
```csharp
string reqUrl = "http://localhost:44837/api/source/test";
using (HttpClient client = new HttpClient(new HttpClientHandler() { UseCookies = false }))//若想手动设置Cookie则必须设置UseCookies = false
{
    //formdata 格式
    string boundary = string.Format("----WebKitFormBoundary{0}", DateTime.Now.Ticks.ToString("x"));
    MultipartFormDataContent content = new MultipartFormDataContent();
    #region 设置请求参数
    content.Headers.ContentType = MediaTypeHeaderValue.Parse("multipart/form-data");
    #endregion
    content.Add(new StringContent("test"), "text");
    content.Add(new StringContent("testid"), "id");
    content.Add(new StreamContent(filestream), "file");
    //json格式
    var result = client.PostAsync(reqUrl, content).Result;
    try
    {
        if (result.IsSuccessStatusCode)
        {
            string rslt = result.Content.ReadAsStringAsync().Result;
            Console.WriteLine(rslt);
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
    finally
    {
        client.Dispose();
    }
}
```

>web api返回自定义格式

使用MediaTypeFormatter

比较常见的返回格式是json，有特殊情况时需要返回其他格式，这时候可以使用FormattedContentResult<T>来指定MediaTypeFormatter返回不同格式。
下面是返回xml格式的例子。
```csharp
public async Task<IHttpActionResult> PostFilesTest([FromForm]AudioText file)
{
    await Task.Delay(100);
    MediaTypeHeaderValue value = new MediaTypeHeaderValue("application/xml");
    FormattedContentResult<AjaxResult<string>> result = new FormattedContentResult<AjaxResult<string>>(HttpStatusCode.OK, AjaxResult<string>.Success("ok"), new XmlMediaTypeFormatter(), value, this);
    return result;
    //return Json(AjaxResult<string>.Success("ok"));
}
```

>httpclient 异常处理

```csharp
using (HttpClient client = new HttpClient(new HttpClientHandler() { UseCookies = false })){
    var result = client.PostAsync(reqUrl, content).Result;
    result.EnsureSuccessStatusCode();//判断http返回状态，如果不是200，则抛出异常信息
    string rslt = result.Content.ReadAsStringAsync().Result;
}
```

> httppost请求body内容参数绑定

* application/x-www-form-urlencoded
* application/json
* multipart/form-data

前面两个 在webapi中都支持模型绑定，使用[FromBody]就能把参数绑定到模型中。     
multipart/form-data 暂时不支持模型绑定，这个类型一般是在上传文件时使用到，web api中关于文件上传的功能也没有使用模型绑定。


解决方案：
自定义MediaTypeFormatter ---- FormDataMediaTypeFormatter

```csharp
public class FormDataMediaTypeFormatter : MediaTypeFormatter
{
    private readonly HttpRequestMessage _request;

    private const string SupportedMediaType = "multipart/form-data";

    public FormDataMediaTypeFormatter()
    {
        SupportedMediaTypes.Add(new MediaTypeHeaderValue(SupportedMediaType));
        SupportedMediaTypes.Add(new MediaTypeHeaderValue("application/x-www-form-urlencoded"));
    }

    public FormDataMediaTypeFormatter(HttpRequestMessage request):this()
    {
        _request = request;
    }
    public override bool CanReadType(Type type)
    {
        return true;
    }

    public override bool CanWriteType(Type type)
    {
        return true;
    }

    public override MediaTypeFormatter GetPerRequestFormatterInstance(Type type, HttpRequestMessage request, MediaTypeHeaderValue mediaType)
    {
        return new FormDataMediaTypeFormatter(request);
    }

    public override async Task<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger)
    {
        object instance = Activator.CreateInstance(type);
        PropertyInfo[] props = type.GetProperties();
        string root = HttpContext.Current.Server.MapPath("~/App_Data");      
        if (content.IsFormData())// application/x-www-form-urlencoded
        {
            var formdata = await content.ReadAsFormDataAsync();
            foreach (var prop in props)
            {
                object[] values = formdata.GetValues(prop.Name.ToLower());
                if (values == null || values.Count() == 0) continue;
                object value = values.FirstOrDefault();
                prop.SetValue(instance, value);
            }
                
        }
        else if (content.IsHttpRequestMessageContent())
        {
            return null;
        }
        else if (content.IsHttpResponseMessageContent())
        {
            return null;
        }
        else if (content.IsMimeMultipartContent())// multipart/form-data
        {
            var provider = new MultipartFormDataStreamProvider(root);

            await content.ReadAsMultipartAsync(provider);
            foreach (var prop in props)
            {
                if (prop.PropertyType == typeof(Collection<MultipartFileData>))
                {
                    prop.SetValue(instance, provider.FileData);
                }
                else {
                    object[] values = provider.FormData.GetValues(prop.Name.ToLower());
                    if (values == null || values.Count() == 0) continue;
                    object value = values.FirstOrDefault();
                    prop.SetValue(instance, value);
                }
            } 
        }
        return instance;
    }
}
```

自定义ParameterBindingAttribute ---- FromFormAttribute

```csharp
public class FromFormAttribute : ParameterBindingAttribute
{
    public override HttpParameterBinding GetBinding(HttpParameterDescriptor parameter)
    {
        //HttpConfiguration config = parameter.Configuration;
        //IEnumerable<ValueProviderFactory> valueProviderFactories = GetValueProviderFactories(config);
        //BufferedMediaTypeFormatter
        //parameter.BindWithFormatter()
        if (parameter.ActionDescriptor.SupportedHttpMethods.Contains(HttpMethod.Post))
        {
            // 使用FormDataMediaTypeFormatter来绑定数据
            return parameter.BindWithFormatter(new FormDataMediaTypeFormatter());
            //return new FromFormBinding(parameter);
        }
        throw new NotImplementedException();
    }
}
```

使用：

```csharp
[Route("testfile")]
[HttpPost]
public IHttpActionResult PostFilesTest([FromForm]AudioText file)
{
    var rq = HttpContext.Current;
    return Json(AjaxResult<string>.Success("ok"));
}
```

该接口可以直接把`application/x-www-form-urlencoded` 和 `multipart/form-data` 类型的数据绑定到模型中

`multipart/form-data`格式是针对文件上传的格式，有文件上传的时候，需要给模型添加一个`Collection<MultipartFileData>`类型的属性，用来绑定文件，属性名称随意。

另外，`HttpParameterBinding`、`IValueProvider`和`ValueProviderFactory`类型也是用来自定义模型绑定的



> 文件上传功能发布到服务器时出现异常

可能原因：

* 文件路径问题，路径不存在? 权限问题?

这种看具体情况排查

* 请求报文问题

ReadAsMultipartAsync方法出现异常unexpected end of MIME multi-part stream when uploading from Flex FileReference

这个是web api的一个bug，可能是因为formdata的结尾没有换行符

```
The issue is really simple but extremely hard to fix. The problem is that Uploadify does > not add an "\r\n" at the end of the MultiPartForm message
```

如果出现这种异常,手动给流添加换行

```
Stream reqStream = Request.Content.ReadAsStreamAsync().Result;
MemoryStream tempStream = new MemoryStream();
reqStream.CopyTo(tempStream);



tempStream.Seek(0, SeekOrigin.End);
StreamWriter writer = new StreamWriter(tempStream);
writer.WriteLine();
writer.Flush();
tempStream.Position = 0;


  StreamContent streamContent = new StreamContent(tempStream);
  foreach(var header in Request.Content.Headers)
  {
      streamContent.Headers.Add(header.Key, header.Value);
  }

// Read the form data and return an async task.
  await streamContent.ReadAsMultipartAsync(provider);
```



[文章](https://stackoverflow.com/questions/13770536/asp-net-web-api-unexpected-end-of-mime-multi-part-stream-when-uploading-from-fl)

>文件上传获取文件名小问题

`MultipartFileData`是通过他的header信息获取文件名的，有时候获取到的文件名带有双引号，这时候需要把双引号去掉

```csharp
string filename = file.Headers.ContentDisposition.FileName;
Console.WriteLine(filename);

//输出:
//"图片1.jpg"
```

>web api 开启session功能时，需要登陆两次才能访问到session

问题描述：写了两个接口，一个登录，一个获取登录信息，第一次登录后，获取信息为空，第二次及之后可以获取到登录信息。这个使用httpclient和html+javascript都试过，是一样的结果。

最后从httpclient中能看出来，第一次登录后没有`Set-Cookie` response headers 返回,也就是没有把session_id返回给客户端，第二次登录时才返回给客户端。

web api 配置：

```csharp
public class WebApiApplication : System.Web.HttpApplication
{
    protected void Application_Start()
    {
        GlobalConfiguration.Configure(WebApiConfig.Register);
    }
    public override void Init()
    {
        //注册事件
        this.AuthenticateRequest += WebApiApplication_AuthenticateRequest;
        base.Init();
    }
    void WebApiApplication_AuthenticateRequest(object sender, EventArgs e)
    {
        //启用 webapi 支持session 会话
        HttpContext.Current.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior.Required);
    }
}
```

解决方案：

```
public class WebApiApplication : System.Web.HttpApplication
{
    protected void Application_Start()
    {
        GlobalConfiguration.Configure(WebApiConfig.Register);
    }
    public override void Init()
    {
        //注册事件
        this.AuthenticateRequest += WebApiApplication_AuthenticateRequest;
        base.Init();
    }
    void WebApiApplication_AuthenticateRequest(object sender, EventArgs e)
    {
        //启用 webapi 支持session 会话
        HttpContext.Current.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior.Required);
    }

    void Session_Start(object sender, EventArgs e)
    {
        // your code here, it will be executed upon session start
    }
}
```

加上了个`Session_Start`就莫名其妙好了。


## swagger

## 优化

>语料文件访问优化

使用缓存，发现还是比直接浏览器访问文件路径要慢

使用etag和last-modified来对视频信息进行缓存（浏览器缓存）

浏览器发送if-non-match和if-modified-since来访问文件。

流程:
首次访问，没有if-non-match和if-modified-since -> 服务器返回etag和last-modified -> 浏览器访问资源 ->再次访问，包含if-non-match和if-modified-since -> 服务器返回etag和last-modified -> 浏览器接收对比，发现没变化，使用缓存。

没有设置etag时，服务端会返回
```http
Expires: -1 
Pragma: no-cache
```


## 问题
>ui这边由于vue组件协调问题，还有工期问题，放弃使用vue，改用普通的html，这样需要解决跨域问题

```csharp
public class CrocsHandle : DelegatingHandler
{
    protected async override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        var response = await base.SendAsync(request, cancellationToken);
        response.Headers.Add("Access-Control-Allow-Origin", "*");
        response.Headers.Add("Access-Control-Allow-Methods", "POST,GET");
        response.Headers.Add("Access-Control-Allow-Headers", "x-requested-with,content-type");
        return response;
    }
}
```

## mongodb问题

>mongodb事务

需求：

* 集群
* 4.0版本及以上

mongodb事务是根据快照来进行回滚的，单机的mongodb是不产生快照(snapshot)的，只有配置了集群，才会产生快照，通过快照来把数据同步到从节点。所以快照是很关键的

```csharp
ReadConcern opread = new ReadConcern(level:ReadConcernLevel.Snapshot);//Snapshot快照
WriteConcern opwriter = new WriteConcern(mode:"majority");//大所数从节点接收到时才确认写入了数据
ClientSessionOptions option = new ClientSessionOptions();
option.DefaultTransactionOptions = new TransactionOptions(readConcern:opread, writeConcern: opwriter);
var session = await client.StartSessionAsync(option);
try
{
    session.StartTransaction();
    dosomething();
    session.CommitTransaction();
}
catch (Exception ex)
{
    await session.AbortTransactionAsync();
}
```

>数组操作问题

在对数组类型push操作时，该字段在MongoDB里不能描述为null，所以在把对象插入collection中时，如果有数组类型的字段，需要初始化，不能为空，否则二次操作push时无法操作。

## 视频读取问题

视频文件可以边看边读，但是有时候视频信息在视频文件的末尾的时候，视频插件会先把整个文件读取完，获取到视频信息才开始播放。