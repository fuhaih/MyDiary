# 项目思维导图

## 上海腾天节能技术有限公司(2016.7-2021.9)

### 重点项目

#### 黄浦沙盘项目

* 项目简介

* 我的职责

* 技术优化

  >封装沙盘服务，实现前端<->后端<->沙盘的实时通信。
  
  接收到前端websocket连接后，注册到沙盘服务中，沙盘服务和沙盘使用socket连接，当沙盘有变动时，会实时发送变更给沙盘服务，沙盘服务再把变更通过websocket传递给前端。
  当前端进行操作时，会把指令通过websocket发送给沙盘服务，沙盘服务再通过socket发送指令给沙盘，让沙盘跟随者变更。
  问题：前端使用websocket发送过大的数据过来的时候，后端websocket需不需要接收多次(buffer很小)。
  >把SendAsync方法改造成Task
  
  使用TaskCompletionSource<T>来改造SendAsync方法，把异步回调方法改造为Task类型的异步方法。

  ```csharp
  TaskCompletionSource<int> source = new TaskCompletionSource<int>();
  sendEvent.UserToken = source;
  sendEvent.SetBuffer(buffer, 0, buffer.Length);
  bool send = socket.SendAsync(sendEvent); 
  if (!send) {
      ProcessSend(sendEvent);
  }
  return source.Task.ContinueWith(task=> {
      ResetEvent.Set();
      return task.Result;
  });
  ```



#### 黄浦区块链项目

* 项目简介

  >地址http://www.ttbems.com/Huangpu/vpp

* 我的职责

* 技术优化

  > 动态构造lambda表达式，实现`IDataReader`到对象的映射。

  ```csharp
  private static Func<IDataReader, T> GetMapFunc<T>(IDataReader dataReader)
  {
      var exps = new List<Expression>();

      var columnNames = Enumerable.Range(0, dataReader.FieldCount)
                          .Select(i => new { i, name = dataReader.GetName(i) });
      #if DEBUG
      Type ttype = typeof(T);
      Debug.WriteLine(string.Format("模型{0}各个字段数据的类型", ttype.Name));
      DataTable table = dataReader.GetSchemaTable();
      for (int i = 0; i < table.Rows.Count; i++)
      {
          string name = System.Convert.ToString(table.Rows[i]["ColumnName"]);
          string type = System.Convert.ToString(table.Rows[i]["DataType"]);
          Debug.WriteLine(string.Format("{0} -- {1}", name, type));
      }
      #endif
      var paramRow = Expression.Parameter(typeof(IDataReader), "row");
      var nullvalue = Expression.Constant(System.DBNull.Value);
      List<MemberBinding> memberBindings = new List<MemberBinding>();

      var indexerInfo = typeof(IDataRecord).GetProperty("Item", new[] { typeof(int) });
      foreach (var column in columnNames)
      {
          var outPropertyInfo = typeof(T).GetProperty(
              column.name,
              BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
          if (outPropertyInfo == null)
              continue;
          var columnNameExp = Expression.Constant(column.i);
          var propertyExp = Expression.MakeIndex(
              paramRow,
              indexerInfo, new[] { columnNameExp });
          var condition = Expression.Equal(propertyExp, nullvalue);
          var convertExp = Expression.Convert(propertyExp, outPropertyInfo.PropertyType);
          var setExp = Expression.Condition(condition, Expression.Default(outPropertyInfo.PropertyType), convertExp);
          MemberBinding memberBinding = Expression.Bind(outPropertyInfo, setExp);
          memberBindings.Add(memberBinding);
      }
      MemberInitExpression init = Expression.MemberInit(Expression.New(typeof(T)), memberBindings.ToArray());
      Expression<Func<IDataReader, T>> lambda = Expression.Lambda<Func<IDataReader, T>>(init, paramRow);
      Func<IDataReader, T> func = lambda.Compile();
      return func;
  }
  ```

  >优化sql分页查询

  区块和数据账簿按照时间查询，然后分页，区块有个自增的区块号BlockNumber，数据账簿有一个自增字段Nonce(不是主键)，思路：数据账簿是根CreateTime、Section字段进行查询分页，所以在该字段中添加索引，优化查询，分页需要使用到自增字段，获取第三页的时候根据CreateTime、Section查询前两页(TOP 20)的最大Nonce，然后再根据CreateTime、Section、Nonce>MaxNonce 来查询第三页(TOP 10)的数据.
  由于获取前两页MaxNonce时只需要使用到Nonce字段，所以在CreateTime、Section索引中可以包含(include)Nonce字段，这样按照非聚集索引CreateTime、Section查询完后，可以直接从索引中获取Nonce值，而不需要再到聚集索引中查找Nonce值。

  这里涉及到聚集索引和非聚集索引的区别：
  表格的所有的列数据信息全都在聚集索引中，如果使用非聚集索引查询，查询完毕后还需要到聚集索引中查询列数据，会有性能消耗，如果使用包含索引的话，这个项目中包含索引包含的是Nonce列，那么查询Nonce列的时候可以直接在非聚集索引中就获取到，不需要再到聚集索引中查询Nonce列数据。

  还涉及到分页：
  目前可以根据自增列来进行分页，获取前n页的自增列的Max值MaxNonce，查询第n页时只需要添加个查询Nonce>MaxNonce就行了，注意第一页需要处理

  还可以使用row_number进行分页，这个最好是在聚集索引分页的时候使用，因为不需要用到自增字段就能分页，一般是直接查询所有需要的列再根据row_number来划分需要的行，所以在非聚集索引中会有性能消耗。也可以用row_number来优化上面的MaxNonce，可以直接根据row_number来获取第n页的初始Nonce，然后再查询。

  可以使用offset/fetch next来实现
  ```sql
  SELECT *
  FROM [TTVVP_System].[dbo].[T_BC_Transaction]
  where CreateTime >='2021-08-14 00:00:00' and CreateTime<'2021-08-20 00:00:00' and Section='ttbemsSub'
  order by Nonce
  offset 80 rows
  fetch next 20 rows only
  ```
  这里同样的，如果CreateTime、Section是非聚集索引，那么由于按照Nonce排序，最好要包含Nonce列，这样相对快一点。

#### 虹桥平台国产化项目

* 项目简介

* 我的职责

* 技术优化

#### 虹口平台项目

* 项目简介
  
  >地址https://hk.ttbems.com/hkarch

* 我的职责

* 技术优化
  
  >使用jwt认证

  > docker部署web api服务

  > 使用nginx托管静态页面、反向代理web api。

#### 汉语考试平台项目

* 项目简介

* 我的职责

* 技术优化

  > mongodb支持collection的事务，但是GridFS不支持，自己实现一个支持事务的GridFS、

  这个是需要知道GridFS的存储结果和方式

  > mp4 视频信息处理，使用别的库处理moov信息，处理某几个视频时会报异常，自己实现了一个moov信息处理方法。

  这个是需要知道mp4的格式解析。

  > mp4的断点续传(range)

  这里主要是考察Range请求头和AcceptRanges响应头。
  下面是.net framework的代码
  ```csharp
    [Route("range/{fileid}")]
    [HttpGet]
    public async Task<HttpResponseMessage> GetRangeFile(string fileid)
    {
        Dictionary<string, string> types = new Dictionary<string, string> {
            { ".jpg","image/jpg"},
            { ".png","image/png"},
            { ".mp4","video/mp4"},
            { ".mp3","audio/mp3"},
            { ".docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"},
            { ".docm","application/vnd.openxmlformats-officedocument.wordprocessingml.document"}
        };
        ObjectId id = new ObjectId(fileid);
        var mongoClient = new MongoClient(GlobalConfig.MongoDbConnectStr);
        var database = mongoClient.LASSTS();
        var bucket = new GridFSBucket(database);
        var query = Builders<GridFSFileInfo>.Filter.Eq("_id", id);
        var fileCursor = await bucket.FindAsync(query);
        GridFSFileInfo fileinfo = fileCursor.FirstOrDefault();
        if (fileinfo == null)
        {
            throw new HttpResponseException(HttpStatusCode.NotFound);
        }
        string extension = Path.GetExtension(fileinfo.Filename);
        string type = "application/octet-stream";
        bool hasSuffix = types.TryGetValue(extension, out type);
        type = hasSuffix ? type : "application/octet-stream";
        GridFSDownloadOptions options = new GridFSDownloadOptions
        {
            Seekable = true
        };
        var stream = await bucket.OpenDownloadStreamAsync(id, options);
        if (Request.Headers.Range != null)
        {
            HttpResponseMessage partialResponse = Request.CreateResponse(HttpStatusCode.PartialContent);
            partialResponse.Content = new ByteRangeStreamContent(stream, Request.Headers.Range, type, 3 * 1024 * 1024);
            return partialResponse;
        }
        else
        {
            HttpResponseMessage fullResponse = new HttpResponseMessage(HttpStatusCode.OK);
            fullResponse.Content = new StreamContent(stream, 3 * 1024 * 1024);
            fullResponse.Content.Headers.ContentType = new MediaTypeHeaderValue(type);
            fullResponse.Headers.AcceptRanges.Add("bytes");
            return fullResponse;
        }
    }
  ```
  .net core中直接可以使用FileResult
  ```csharp
  File("/test.txt", "application/octet-stream", "test.txt", true);
  //
  // 摘要:
  //     Returns the file specified by virtualPath (Microsoft.AspNetCore.Http.StatusCodes.Status200OK)
  //     with the specified contentType as the Content-Type and the specified fileDownloadName
  //     as the suggested file name. This supports range requests (Microsoft.AspNetCore.Http.StatusCodes.Status206PartialContent
  //     or Microsoft.AspNetCore.Http.StatusCodes.Status416RangeNotSatisfiable if the
  //     range is not satisfiable).
  //
  // 参数:
  //   virtualPath:
  //     The virtual path of the file to be returned.
  //
  //   contentType:
  //     The Content-Type of the file.
  //
  //   fileDownloadName:
  //     The suggested file name.
  //
  //   enableRangeProcessing:
  //     Set to true to enable range requests processing.
  //
  // 返回结果:
  //     The created Microsoft.AspNetCore.Mvc.VirtualFileResult for the response.
  [NonAction]
  public virtual VirtualFileResult File(string virtualPath, string contentType, string fileDownloadName, bool enableRangeProcessing);
  ```

#### 平台数据规整项目

* 项目简介

* 我的职责

* 技术优化

  >优化原有的项目，使用rabbitmq的生产者消费者模式，把规整任务分发到多台服务器中处理，让规整任务延迟在15分钟内。



#### 平台地标服务项目

* 项目简介

* 我的职责

* 技术优化

  >优化原有socket项目，使用SocketAsyncEventArgs来实现io多路复用，实现socket同时上千+个连接
  
  io多路复用，缓冲区复用
  >添加客户端连接阈值，避免劣质客户端占用资源

  有些客户端是业主那边做的，会不断创建连接却又不释放，使用信号量来限制每个客户端的连接数量，超出就会关闭连接。

### 其他项目

#### 朗新cps数据同步项目

* 项目简介

* 我的职责

* 技术优化

  >Refit



#### rpa自动化流程项目

* 项目简介

* 我的职责

* 技术优化

  >使用状态机

  >wpf

#### 虚拟电厂上报程序

* 项目简介

* 我的职责

* 技术优化

#### 长宁通用流程管理

* 项目简介

* 我的职责

* 技术优化

#### 平台专业版

* 项目简介

* 我的职责

* 技术优化

#### 充电桩对接

* 项目简介

* 我的职责

* 技术优化

#### 异常判定

* 项目简介

* 我的职责

* 技术优化

#### 数据预测项目

* 项目简介

* 我的职责

* 技术优化