# 功能描述

* 刷卡、扫码枪、人脸识别

键盘钩子无光标获取扫码枪数据、人脸识别的话是通过人脸识别系统的接口获取最新的人脸信息(设备id)

三个线程来处理三个逻辑

然后把数据推送到另外一个线程中，进行单线程处理患者信息，判断如果有体重秤信息(体重秤稳定并且大于最小阈值)，那么加锁，保存患者体重

* 体重秤信息

一个线程通过串口或者tcp方式来获取体重秤信息，获取到体重信息再扔进另一个线程的数据队列中处理，避免处理体重的过程中阻塞，影响后面体重信息接收

体重数据处理流程

数据接收(根据配置来判断是com口还是tcp，实现不同的协议来接收数据)->数据解析(根据配置来解析数据)->判断稳定称重->体重数据处理

整个的流程是这样，如果有其他协议，只需要实现对应的类就行了，不会影响整个流程的代码

数据接收：接口类，不同协议有不同的实现类

数据解析：每个体重秤品牌和型号的数据格式都不太一样，这里通过正则表达式来解析数据格式，可以解析出来体重数据和体重秤的稳定标识，有些体重秤发送过来的数据是有稳定标识的

解析后的数据用自己弄的领域语言来进行数据的处理，比如说翻转、取两位小数、转换为double、判断语句（主要用在判断稳定标识）等，一些需要使用byte来处理的格式，可以通过转换为16进制格式来匹配正则表达式，然后用领域语言把16进制数据转换为10进制

稳定称重：一个是可以根据体重秤的稳定标识来实现，一个是自定义的稳定称重逻辑，即n次的体重值在mkg范围内就算为稳定

处理体重信息：如果有患者信息，并且体重信息稳定且大于最小阈值，那么加锁，保存患者体重

* 面板清空

单独一个线程来判断患者信息和体重信息超时清空

称重成功后会清空患者信息

患者信息如果和体重信息都会判断超时，超时后会清空

体重信息如果是连续发送数据过来的，就不会超出超时时间，也就不会清空，会跟着体重秤不断变化显示

有些体重秤是称重成功后才发送一条数据，体重数据不会经常更新，那么要定时判断超时清空，避免有人称重后滞留信息，被患者刷卡保存




# 领域语言

这里通过`Irony`包来实现词法分析，生成树状结构，然后转换为.net的lambda表达式树

词法分析：
```csharp
[Language("MyLanguage", "1.0", "My custom language")]
public class SwlGrammar : Grammar
{
    public SwlGrammar() : base(caseSensitive: true)
    {
        // 定义终结符和非终结符
        var number = new NumberLiteral("number");
        var identifier = new IdentifierTerminal("identifier");
        var stringLiteral = new StringLiteral("stringLiteral", "\"", StringOptions.AllowsLineBreak);
        var expression = new NonTerminal("expression");
        var comparisonOperator = new NonTerminal("comparisonOperator");
        var comparisonExpression = new NonTerminal("comparisonExpression");
        var additiveOperator = new NonTerminal("additiveOperator");
        var additiveExpression = new NonTerminal("additiveExpression");
        var multiplicativeOperator = new NonTerminal("multiplicativeOperator");
        var multiplicativeExpression = new NonTerminal("multiplicativeExpression");
        var parameter = new NonTerminal("parameter");

        //int double转换方法
        var conversionMethod = new NonTerminal("conversionMethod");
        var convarsionMethodName = new NonTerminal("convarsionMethodName");
        //substring方法
        var substringMethod = new NonTerminal("substringMethod");
        var substringParameter = new NonTerminal("substringParameter");
        //round
        var roundMethod = new NonTerminal("roundMethod");

        //reverse
        var reverseMethod = new NonTerminal("reverseMethod");

        var parenExpression = new NonTerminal("parenExpression");

        // 定义语法规则
        convarsionMethodName.Rule = ToTerm("int") | "double" | "hex2int16" | "hex2int32" | "hex2int64"| "hex2ascii";
        conversionMethod.Rule = convarsionMethodName + "(" + expression + ")";
        parameter.Rule = ToTerm("$") + number | ToTerm("$") + identifier;
        substringParameter.Rule = stringLiteral | parameter;
        substringMethod.Rule = ToTerm("substring") + "(" + substringParameter + "," + number + "," + number + ")";
        roundMethod.Rule = ToTerm("round") + "(" + expression + "," + number + ")";
        reverseMethod.Rule = ToTerm("reverse") + "(" + expression +")";
        //stringLiteral.Rule = Optional(substringMethod) + "\"" + new StringSettings() { AllowNewLineInValue = true } + "\"";
        //number.Rule = Optional(conversionMethod) + Number;
        comparisonExpression.Rule = expression + comparisonOperator + expression;
        additiveExpression.Rule = expression + additiveOperator + expression;
        multiplicativeExpression.Rule = expression + multiplicativeOperator + expression;
        parenExpression.Rule = "(" + expression + ")";
        expression.Rule = number | identifier | stringLiteral | parameter | substringMethod | conversionMethod | roundMethod| reverseMethod|
            multiplicativeExpression |
            additiveExpression |
            comparisonExpression | 
            parenExpression;

        comparisonOperator.Rule = ToTerm("<") | "<=" | ">" | ">=" | "==";

        additiveOperator.Rule = ToTerm("+") | "-";

        multiplicativeOperator.Rule = ToTerm("*") | "/" | "%";

        this.Root = expression;

        // 设置优先级和结合性
        RegisterOperators(1, "+", "-");
        RegisterOperators(2, "*", "/", "%");
        RegisterOperators(3, "<", "<=", ">", ">=", "==");
        MarkPunctuation("(", ")");
        MarkTransient(expression);
    }
}
```

转换为lambda表达式树

```csharp
/// <summary>
/// swl解析器
/// </summary>
public class SwlParser
{
    private static Logger _logger = LogManager.GetCurrentClassLogger();

    /// <summary>
    /// 把表达式解析为可执行的委托
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="partten"></param>
    /// <returns></returns>
    public static Func<Dictionary<string, string>, T> TryParse<T>(string partten)
    {
        try
        {
            return Parse<T>(partten);
        }
        catch (Exception ex)
        {
            _logger.Error(ex);
            return null;
        }
    }

    /// <summary>
    /// 把公式解析为可执行的委托
    /// </summary>
    /// <param name="partten"></param>
    /// <returns></returns>
    public static Func<Dictionary<string, string>, T> Parse<T>(string partten)
    {
        var grammar = new SwlGrammar();
        var parser = new Parser(grammar);
        var parseTree = parser.Parse(partten);
        if (parseTree.HasErrors())
        {
            // 处理解析错误
            foreach (var error in parseTree.ParserMessages)
            {
                //Console.WriteLine(error.Message);
                
            }
            throw new Exception("解析异常");
        }
        else
        {
            // 处理解析结果
            var expressionNode = parseTree.Root;
            ParameterExpression parameter = Expression.Parameter(typeof(Dictionary<string, string>), "p1");
            var expression = EvaluateExpression(expressionNode,parameter);
            if (expression.Type != typeof(T))
            {
                expression = Expression.Convert(expression, typeof(T));
            }
            Func<Dictionary<string,string>,T> func = Expression.Lambda<Func<Dictionary<string,string>, T>>(expression, new ParameterExpression[] { parameter}).Compile();
            return func;
            //Console.WriteLine(value);
        }
    }

    /// <summary>
    /// 解析表达式
    /// </summary>
    /// <param name="node"></param>
    /// <param name="parameters"></param>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException"></exception>
    private static Expression EvaluateExpression(ParseTreeNode node, ParameterExpression parameters)
    {
        switch (node.Term.Name)
        {
            case "number":
                {
                    if (node.Token.Text.IndexOf(".") >= 0)
                    {
                        return Expression.Constant(double.Parse(node.Token.Text));
                    }
                    else
                    {
                        return Expression.Constant(int.Parse(node.Token.Text));
                    }
                }

            case "conversionMethod":
                {
                    var conversionMethodName = node.ChildNodes[0].ChildNodes[0].Token.Text;
                    var value = EvaluateExpression(node.ChildNodes[1], parameters);
                    switch (conversionMethodName)
                    {
                        case "int":
                            //return Convert.ToInt32(value);
                            {
                                if (value.Type == typeof(string))
                                {
                                    MethodInfo method = typeof(int).GetMethod("Parse",
                                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                                        null,
                                        CallingConventions.Any,
                                        new Type[] { typeof(string) },
                                        null);
                                    return Expression.Call(null, method, new Expression[] { value });

                                }
                                else { 
                                    return Expression.Convert(value, typeof(int));
                                }
                            }
                        case "double":
                            {
                                if (value.Type == typeof(string))
                                {
                                    MethodInfo method = typeof(double).GetMethod("Parse",
                                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                                        null,
                                        CallingConventions.Any,
                                        new Type[] { typeof(string) },
                                        null);
                                    return Expression.Call(null, method, new Expression[] { value });

                                }
                                else {
                                    return Expression.Convert(value, typeof(double));
                                }
                            }
                        case "float":
                            {
                                if (value.Type == typeof(string))
                                {
                                    MethodInfo method = typeof(float).GetMethod("Parse",
                                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                                        null,
                                        CallingConventions.Any,
                                        new Type[] { typeof(string) },
                                        null);
                                    return Expression.Call(null, method, new Expression[] { value });

                                }
                                else {
                                    return Expression.Convert(value, typeof(float));
                                }
                            }
                        case "hex2int16":
                            {
                                //Convert.ToInt16("", 16);
                                MethodInfo method = typeof(Convert).GetMethod("ToInt16",
                                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                                        null,
                                        CallingConventions.Any,
                                        new Type[] { typeof(string),typeof(int)},
                                        null);
                                return Expression.Call(null, method, new Expression[] { value, Expression.Constant(16)});
                            }
                        case "hex2int32":
                            {
                                //Convert.ToInt32();
                                MethodInfo method = typeof(Convert).GetMethod("ToInt32",
                                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                                        null,
                                        CallingConventions.Any,
                                        new Type[] { typeof(string), typeof(int) },
                                        null);
                                return Expression.Call(null, method, new Expression[] { value, Expression.Constant(16) });
                            }
                        case "hex2int64":
                            {
                                //Convert.ToInt64();
                                MethodInfo method = typeof(Convert).GetMethod("ToInt64",
                                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                                        null,
                                        CallingConventions.Any,
                                        new Type[] { typeof(string), typeof(int) },
                                        null);
                                return Expression.Call(null, method, new Expression[] { value, Expression.Constant(16) });
                            }
                        //16进制转阿斯特码字符
                        case "hex2ascii":
                            {
                                MethodInfo method = typeof(EncodingHelper).GetMethod("HexToASCII",
                                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                                        null,
                                        CallingConventions.Any,
                                        new Type[] { typeof(string) },
                                        null);
                                return Expression.Call(null, method, new Expression[] { value });
                            }
                        default:
                            throw new InvalidOperationException($"Invalid conversion method: {conversionMethodName}");
                    }
                }
                
            case "substringMethod":
                //return node.Token.ValueString;
                {
                    var expression = EvaluateExpression(node.ChildNodes[1], parameters);
                    var args1 = EvaluateExpression(node.ChildNodes[3], parameters);
                    var args2 = EvaluateExpression(node.ChildNodes[5], parameters);
                    MethodInfo method = typeof(string).GetMethod("Substring",
                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                        null,
                        CallingConventions.Any,
                        new Type[] { typeof(int), typeof(int) },
                        null);
                    return Expression.Call(expression, (MethodInfo)method, new Expression[] { args1, args2 });
                }
            case "roundMethod":
                {
                    var args1 = EvaluateExpression(node.ChildNodes[1], parameters);
                    var args2 = EvaluateExpression(node.ChildNodes[3], parameters);
                    MethodInfo method = typeof(Math).GetMethod("Round",
                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                        null,
                        CallingConventions.Any,
                        new Type[] { args1.Type, args2.Type },
                        null);
                    if(method==null)
                    {
                        throw new MethodNotFoundException("round", args1.Type, args2.Type);
                    }
                    return Expression.Call(null, (MethodInfo)method, new Expression[] { args1, args2 });

                }
            case "reverseMethod":
                {
                    //new string("".Reverse().ToArray());
                    var args1 = EvaluateExpression(node.ChildNodes[1], parameters);

                    var reverseMethods =
                        // Get all the M methods 
                        from mi in typeof(Enumerable).GetMethods(BindingFlags.Public | BindingFlags.Static)
                        where mi.Name == "Reverse"

                        // that are generic with one type parameter 
                        where mi.IsGenericMethod
                        where mi.GetGenericArguments().Length == 1
                        let methodTypeParameter = mi.GetGenericArguments()[0]

                        // that have two formal parameters 
                        let ps = mi.GetParameters()
                        where ps.Length == 1

                        // the first of which is IEnumerable<the method type parameter> 
                        where ps[0].ParameterType.IsGenericType
                        where ps[0].ParameterType.GetGenericTypeDefinition() == typeof(IEnumerable<>)
                        where ps[0].ParameterType.GetGenericArguments()[0] == methodTypeParameter

                        select mi;
                    MethodInfo reverseMethod = reverseMethods.FirstOrDefault();
                    if (reverseMethod == null)
                    {
                        throw new MethodNotFoundException("reverse");
                    }

                    if (args1.Type != typeof(string))
                    {
                        throw new MethodNotFoundException("reverse 方法的参数不是字符串");
                    }
                    var charList = Expression.Call(null,reverseMethod.MakeGenericMethod(typeof(char)), new Expression[] { args1 });

                    var toArrayMethods =
                        // Get all the M methods 
                        from mi in typeof(Enumerable).GetMethods(BindingFlags.Public | BindingFlags.Static)
                        where mi.Name == "ToArray"

                        // that are generic with one type parameter 
                        where mi.IsGenericMethod
                        where mi.GetGenericArguments().Length == 1
                        let methodTypeParameter = mi.GetGenericArguments()[0]

                        // that have two formal parameters 
                        let ps = mi.GetParameters()
                        where ps.Length == 1

                        // the first of which is IEnumerable<the method type parameter> 
                        where ps[0].ParameterType.IsGenericType
                        where ps[0].ParameterType.GetGenericTypeDefinition() == typeof(IEnumerable<>)
                        where ps[0].ParameterType.GetGenericArguments()[0] == methodTypeParameter

                        select mi;
                    MethodInfo toArrayMethod = toArrayMethods.FirstOrDefault();
                    if (reverseMethod == null)
                    {
                        throw new MethodNotFoundException("ToArray");
                    }


                    var charArray = Expression.Call(null, toArrayMethod.MakeGenericMethod(typeof(char)), new Expression[] { charList });
                    var construct = typeof(string).GetConstructor(new Type[] { typeof(char[]) });
                    return Expression.New(construct, charArray);
                }
            case "stringLiteral":
                {
                    return Expression.Constant(node.Token.ValueString);
                }
            case "parameter":
                {
                    var paramKey = node.ChildNodes[1].Token.ValueString;
                    var indexParameters = new List<Expression>()
                    {
                        Expression.Constant("$"+paramKey)
                    };
                    var indexer = GetIndexer(parameters,new Type[] { typeof(string)});
                    return Expression.MakeIndex(parameters, indexer, indexParameters);
                }
            case "comparisonExpression":
                { 
                    string operatorValue = node.ChildNodes[1].ChildNodes[0].Token.ValueString;
                    Expression left = EvaluateExpression(node.ChildNodes[0], parameters);
                    Expression right = EvaluateExpression(node.ChildNodes[2], parameters);
                    switch (operatorValue)
                    {
                        case "<":  return Expression.LessThan(left, right);
                        case ">":  return Expression.GreaterThan(left, right);
                        case "<=": return Expression.LessThanOrEqual(left, right);
                        case ">=": return Expression.GreaterThanOrEqual(left, right);
                        case "==": return Expression.Equal(left, right);
                        default:
                            throw new InvalidOperationException($"Invalid operator: {operatorValue}");
                    }
                }
            case "additiveExpression":
                {
                    string operatorValue = node.ChildNodes[1].ChildNodes[0].Token.ValueString;
                    Expression left = EvaluateExpression(node.ChildNodes[0], parameters);
                    Expression right = EvaluateExpression(node.ChildNodes[2], parameters);
                    switch (operatorValue)
                    {
                        case "+":
                            {
                                if (left.Type == typeof(string) || right.Type == typeof(string))
                                {
                                    MethodInfo method = typeof(string).GetMethod("Concat",
                                        BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static,
                                        null,
                                        CallingConventions.Any,
                                        new Type[] { typeof(object), typeof(object) },
                                        null);
                                    return Expression.Call(null, (MethodInfo)method, new Expression[] { left, right });
                                }
                                else
                                {
                                    return Expression.Add(left, right);
                                }
                            }
                        case "-": return Expression.Subtract(left, right);
                        default:
                            throw new InvalidOperationException($"Invalid operator: {operatorValue}");
                    }
                }
            case "multiplicativeExpression":
                {

                    string operatorValue = node.ChildNodes[1].ChildNodes[0].Token.ValueString;
                    Expression left = EvaluateExpression(node.ChildNodes[0], parameters);
                    Expression right = EvaluateExpression(node.ChildNodes[2], parameters);
                    switch (operatorValue)
                    {
                        case "*": return Expression.Multiply(left, right);
                        case "/":
                            {
                                if (right.Type != left.Type)
                                { 
                                    right = Expression.Convert(right, left.Type);
                                }
                                return Expression.Divide(left, right);
                            }
                        case "%": return Expression.Modulo(left, right);
                        default:
                            throw new InvalidOperationException($"Invalid operator: {operatorValue}");
                    }
                }
            case "convarsionParameter":
            case "substringParameter":
            case "parenExpression":
            case "expression":
                {
                    return EvaluateExpression(node.ChildNodes[0], parameters);
                }
            default:
                throw new InvalidOperationException($"Invalid expression node: {node.Term.Name}");
        }
    }

    /// <summary>
    /// 获取下标属性
    /// </summary>
    /// <param name="expression"></param>
    /// <param name="parameters"></param>
    /// <returns></returns>
    public static PropertyInfo GetIndexer(Expression expression, Type[] parameters)
    {
        var properties = expression.Type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
        foreach (var property in properties)
        {
            ParameterInfo[] parameterInfo = property.GetIndexParameters();
            Type[] parameterInfoType = parameterInfo.Select(x => x.ParameterType).ToArray();
            if (parameterInfoType.Length == parameters.Length && parameters.ArrayEquals(parameterInfoType))
            {
                return property;
            }
        }
        return null;
    }
}
```

例子：




```csharp
//数据 =01.48  B 使用正则匹配
Regex regex = new Regex("(\\w+)\\s+(\\d+.\\d+)kg");
var matchs = regex.Matches("=01.48  B");
Dictionary<string, string> values = new Dictionary<string, string>();
for (int i = 1; i < match.Groups.Count; i++)
{
    values.Add("$" + i.ToString(), match.Groups[i].Value);
}
//得出两个分组数据
//$1:01.48
//$2:B
Func<Dictionary<string, string>, double> weightPattern = SwlParser.TryParse<bool>("double(reverse($1))");
Func<Dictionary<string, string>, bool> balanceMarkPattern = SwlParser.TryParse<bool>("$2==\"B\"");
double weight = weightPattern(values); //84.1
bool isBalance = balanceMarkPattern(values);// true
```
`double(reverse($1))`和`$2==\"B\"` 这两个就是领域语言，`$1`和`$2`为正则表达式匹配到的分组信息，通过领域语言处理正则表达式的分组信息

程序通过正则表达式匹配体重数据，解析出分组信息，构造一个参数字典

程序通过领域语言解析语言代码，构造lambda表达式

把参数字典作为参数代入表达式，得出想要的结果

