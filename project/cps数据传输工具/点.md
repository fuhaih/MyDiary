# 功能

调用对方api接口，定时同步数据过去

# refit 使用

包：

`Refit.HttpClientFactory`

```csharp
public interface ISynchronizeClient
{
    [Post("/v1/collection/datas")]
    Task<DataReply> AlarmEvent(History data, [Header("access_token")] string token);
}
```

注入对象

```csharp
services.AddRefitClient<ISynchronizeClient>()
                .ConfigureHttpClient(c => c.BaseAddress = new Uri(BaseAddress));
```

# ef core

## 入门

包：

`Microsoft.EntityFrameworkCore`

`Microsoft.EntityFrameworkCore.SqlServer`

>编写实体类

```csharp
[Table("T_CPS_Client")]
public class Client
{
    [Key]
    public string CustomerId { get; set; }
    public string ClientId { get; set; }
    public string ClientSecret { get; set; }
    public int State { get; set; }
}
```

>context

```csharp
public class SynchronizeContext: ContextBase
{
    public SynchronizeContext(DbContextOptions<SynchronizeContext> option) : base(option) { 
    }
    public DbSet<Client> Clients { get; set; }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Client>().HasKey(c => c.CustomerId);
    }
}
```

实体需要指定主键，可以在实体模型中使用`[Key]`特性来指定，也可以在Context中的`OnModelCreating`方法指定主键。

当主键是联合主键时，只能在`OnModelCreating`中进行配置

如果某个实现不需要使用主键，可以直接`modelBuilder.Entity<Client>().HasNoKey()`

>注入

```csharp
services.AddDbContext<SynchronizeContext>(option =>
{
    option.UseSqlServer(ConnectString);
});
```

>去除实体跟踪

使用`AsNoTracking`
```csharp
context.Clients.AsQueryable().Where(m=>m.CustomerId=="customerid").AsNoTracking().ToListAsync();
```

## 泛型使用

正常使用时候，context需要频繁修改，添加`DbSet<Client>`字段，

Context有Set方法可以直接获取到DbSet对象

```csharp
context.Set<Clients>().AsQueryable().Where(m=>m.CustomerId=="customerid").AsNoTracking().ToListAsync();
```

如果是这样使用，可以不用在Context对象中添加相关的DbSet<> 字段，但是要在`OnModelCreating`中进行配置，为了简化配置，可以使用反射来获取所有的实体模型然后配置到Context里

>Context 

```csharp
public class SynchronizeContext: ContextBase
{
    public SynchronizeContext(DbContextOptions<SynchronizeContext> option) : base(option) { 
    }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        var types = AppDomain.CurrentDomain.GetAssemblies().SelectMany(m => m.GetTypes().Where(t => t.Namespace == "SynchronizeCPSData.Models.CPS"));
        foreach (Type type in types) {
            TableAttribute attribute = type.GetCustomAttribute<TableAttribute>();
            if (attribute != null)
            {
                
                EntityTypeBuilder builder = modelBuilder.Entity(type);
                HasNoKeyAttribute hasNoKey = type.GetCustomAttribute<HasNoKeyAttribute>();
                if (hasNoKey!=null)
                {
                    builder.HasNoKey();
                    continue;
                }
                HasKeyAttribute hasKey = type.GetCustomAttribute<HasKeyAttribute>();
                if (hasKey != null) {
                    builder.HasKey(hasKey.PropertyNames);
                }
            }          
        }
    }
}
```

>自定义特性

看上面的Context的`OnModelCreating`方法，`modelBuilder.Entity(type)`方法会根据你的`[Key]`特性来配置主键，但是联合主键没有类似的方法，所以自定义了两个特性来完成操作

`HasNoKeyAttribute` 和 `HasKeyAttribute`

`HasNoKeyAttribute`是用来配置没有主键的节点

`HasKeyAttribute`是用来配置联合主键




