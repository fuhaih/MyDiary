socket 使用asyncsocketeventargs
iocp
# 数据结构

>线程安全集合

# socket

>滑动窗口
滑动窗口解决的问题：
数据包从发送端发送到接收端，再等待接收端发送回应，这中间的时间被浪费了
滑动窗口一次性发送窗口大小的多个数据包，在接收到回应时，把接收到的数据划出窗口，新的数据划入窗口并发送到接收端。
如果某个数据包接收到了回应，它前面的数据包没有接收到回应，就会等待前面数据包回应，然后一起划出窗口。

>ReceiveBufferSize缓冲区

socket有两个缓冲区，数据发送缓冲区，数据接收缓冲区
在发送数据时，如果接收方的接收缓冲区已经满了，发送方会阻塞。

所以客户端最好也处理好从服务端发送过来的数据，否则客户端的接收缓冲区满了之后，服务端的发送方法会阻塞，这就导致服务器不会处理客户端发送过去的数据。

>使用asyncsocketeventargs

异步处理


>连接三次握手、关闭四次握手(状态)

连接
SYN,Seq=ISN(c)
SYN+ACK,Seq=ISN(s),ACK=ISN(c)
ACK,Seq=ISN(c)+1,ACK=ISN(s)+1

关闭
FIN+ACK,Seq=K,ACK=L
ACK,Seq=L,ACK=K+1
FIN+ACK,Seq=L,ACK=K+1
ACK,Seq=K,ACK=L+1


>LingerOption 

关闭的时候，socket是等待发送队列的数据发送完才会真正关闭的，LingerOption可以设置忽略发送队列数据直接关闭，或者是更改等待时间，在设置的时间内还没有发送就直接关闭。

>保护消息边界

一个标志位+数据长度。

>连接重置

普通关闭需要双方都关闭，否则主动关闭方会出现fin_wait_2状态，socket并没有真正关闭的情况。
重置连接就会忽略掉被关闭方，单方面的强制关闭连接。

>socket连接状态

主动关闭方

established

fin_wait_1

fin_wait_2

fin_wait_1到fin_wait_2的转换是很快的。fin_wait_2一直存在说明被关闭方没有关闭socket

time_wait(会等待两倍最大生存时间，一般为30秒、1分钟、2分钟) 这个是用来确保最后的ack传输到被关闭方。


# 问题
>大量连接没有释放。
出现这个问题后，查看连接，发现很多socket连接都是处在fin_wait_2状态，也就是其实服务端已经发起关闭操作了，但是客户端没有执行关闭操作。
客户端不是这边写的，所以才从服务端关闭连接来处理。出现这个问题就需要和客户端开发者联系修改。
也可以使用连接重置，不过目前还没找到c# socket的连接重置方法。
