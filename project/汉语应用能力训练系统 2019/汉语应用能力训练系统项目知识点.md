
## rabbitmq问题

>默认交换器

rabbitmq在安装完后会有一个默认的交换器，名字是空的，每个queue都会和该交换器有一个binding，bindingkey就是queuename;
该交换器是持久的，direct类型的。所以在使用简单的direct类型交换器可以直接用默认的；

```csharp
//申明一个队列，这时已经和默认交换器绑定了，bingdingkey就是队列名test
model.QueueDeclare("test", false, false, false, null);
byte[] data = Encoding.UTF8.GetBytes(teststr);
//在发布时，交换器名称为空，就会直接给默认交换器，然后bingdingkey为test，就直接把数据给队列test了。
model.BasicPublish("", "test", props, data);
```

>服务质量
```csharp
//参数
//prefetchSize:滑动窗口数量，消费端会根据 prefetchSize 的大小批量获取数据，比如说默认值是1000，那么消费者就会预先加载1000条数据到本地的内存中
//prefetchCount:允许最多prefetchCount个ack没确认（ack没确认表明消息没有消费完成），当prefetchCount为2时，也就是允许消费端同时消费两个消息；
//global：true\false 是否将上面设置应用于channel，简单点说，就是上面限制是channel级别的还是consumer级别
model.BasicQos(0, subscriber.PrefetchCount, false);
```
>消息多发（使用临时队列）

使用场景：消费端多发情况，也就是当某个消息是要发送到多个消费端的时候，

```csharp
//durable：true、false true：在服务器重启时，能够存活
//exclusive ：是否为当前连接的专用队列，在连接断开后，会自动删除该队列，生产环境中应该很少用到吧。
//autodelete：当没有任何消费者使用时，自动删除该队列。this means that the queue will be deleted when there are no more processes consuming messages from it.
var result = model.QueueDeclare("", true, true, true, null);
model.QueueBind(result.QueueName, "test", "test",null);

```
首先创建一个Fanout类型的交换器test，该交换器会把消息发送到所有绑定到该交换器上的队列

消费端创建一个空名称的队列，rabbitmq会自动生成一个类似amq.gen-JzTY20BRgKO-HjmUJj0wLg的队列名，然后后面各个参数为true，当消费端断开连接时，队列就会删除。

然后把新建的队列绑定到多发交换器test上。

当多个消费端连接时，就会生成多个队列，绑定到test，消息发送时就能实现多发。当有消费端断开时，对应的队列就会被删除。

## web api问题

> 常见的请求body类型

* application/x-www-form-urlencoded

格式：以`&`号连接多个参数
```
a=1&b=2
```

* application/json

普通json格式

* multipart/form-data

以boundary来划分多个数据。
```http
POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryRBSecJmkpXmr64GL

------WebKitFormBoundaryRBSecJmkpXmr64GL
Content-Disposition: form-data; name="id"

123
------WebKitFormBoundaryRBSecJmkpXmr64GL
Content-Disposition: form-data; name="text"

123
------WebKitFormBoundaryRBSecJmkpXmr64GL
Content-Disposition: form-data; name="files"; filename="edusoho.txt"
Content-Type: text/plain #这里说明文件是文本类型，如果是图片就会是image/png

data of file
------WebKitFormBoundaryRBSecJmkpXmr64GL--
```

请求头中设置`Content-Type`为`multipart/form-data`，后面带一个`boundary`，`boundary`可以自己定义



>[FromBody] [FromUri]误用

这两个特性不能用在默认数据格式中，是在使用一个复杂类来接收参数对象时使用的。

>httpclient 发送数据

* application/x-www-form-urlencoded  

这个是form表单的格式，以`&`号来连接各个参数，如`a=1&b=2`;

* application/json 

这个就是普通的json格式

* multipart/form-data

这个格式一般是用来传输文件的，同时也能传递其他参数。

**发送application/json格式数据**

```csharp
string reqUrl = "http://localhost:44837/api/source/test";
using (HttpClient client = new HttpClient(new HttpClientHandler() { UseCookies = false }))//若想手动设置Cookie则必须设置UseCookies = false
{
    //json格式
    HttpContent content = new StringContent("{\"id\":\"testid\",\"text\":\"text\"}");
    content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/json");
    var result = client.PostAsync(reqUrl, content).Result;
    try
    {
        if (result.IsSuccessStatusCode)
        {
            string rslt = result.Content.ReadAsStringAsync().Result;
            Console.WriteLine(rslt);
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
    finally
    {
        client.Dispose();
    }
}
```

**发送application/x-www-form-urlencoded格式数据**

FormUrlEncodedContent

```csharp

```

**发送multipart/form-data格式数据**
```csharp
string reqUrl = "http://localhost:44837/api/source/test";
using (HttpClient client = new HttpClient(new HttpClientHandler() { UseCookies = false }))//若想手动设置Cookie则必须设置UseCookies = false
{
    //formdata 格式
    string boundary = string.Format("----WebKitFormBoundary{0}", DateTime.Now.Ticks.ToString("x"));
    MultipartFormDataContent content = new MultipartFormDataContent();
    #region 设置请求参数
    content.Headers.ContentType = MediaTypeHeaderValue.Parse("multipart/form-data");
    #endregion
    content.Add(new StringContent("test"), "text");
    content.Add(new StringContent("testid"), "id");
    content.Add(new StreamContent(filestream), "file");
    //json格式
    var result = client.PostAsync(reqUrl, content).Result;
    try
    {
        if (result.IsSuccessStatusCode)
        {
            string rslt = result.Content.ReadAsStringAsync().Result;
            Console.WriteLine(rslt);
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
    finally
    {
        client.Dispose();
    }
}
```

>web api返回自定义格式

使用MediaTypeFormatter

比较常见的返回格式是json，有特殊情况时需要返回其他格式，这时候可以使用FormattedContentResult<T>来指定MediaTypeFormatter返回不同格式。
下面是返回xml格式的例子。
```csharp
public async Task<IHttpActionResult> PostFilesTest([FromForm]AudioText file)
{
    await Task.Delay(100);
    MediaTypeHeaderValue value = new MediaTypeHeaderValue("application/xml");
    FormattedContentResult<AjaxResult<string>> result = new FormattedContentResult<AjaxResult<string>>(HttpStatusCode.OK, AjaxResult<string>.Success("ok"), new XmlMediaTypeFormatter(), value, this);
    return result;
    //return Json(AjaxResult<string>.Success("ok"));
}
```

>httpclient 异常处理

```csharp
using (HttpClient client = new HttpClient(new HttpClientHandler() { UseCookies = false })){
    var result = client.PostAsync(reqUrl, content).Result;
    result.EnsureSuccessStatusCode();//判断http返回状态，如果不是200，则抛出异常信息
    string rslt = result.Content.ReadAsStringAsync().Result;
}
```

> httppost请求body内容参数绑定

* application/x-www-form-urlencoded
* application/json
* multipart/form-data

前面两个 在webapi中都支持模型绑定，使用[FromBody]就能把参数绑定到模型中。     
multipart/form-data 暂时不支持模型绑定，这个类型一般是在上传文件时使用到，web api中关于文件上传的功能也没有使用模型绑定。


解决方案：
自定义MediaTypeFormatter ---- FormDataMediaTypeFormatter

```csharp
public class FormDataMediaTypeFormatter : MediaTypeFormatter
{
    private readonly HttpRequestMessage _request;

    private const string SupportedMediaType = "multipart/form-data";

    public FormDataMediaTypeFormatter()
    {
        SupportedMediaTypes.Add(new MediaTypeHeaderValue(SupportedMediaType));
        SupportedMediaTypes.Add(new MediaTypeHeaderValue("application/x-www-form-urlencoded"));
    }

    public FormDataMediaTypeFormatter(HttpRequestMessage request):this()
    {
        _request = request;
    }
    public override bool CanReadType(Type type)
    {
        return true;
    }

    public override bool CanWriteType(Type type)
    {
        return true;
    }

    public override MediaTypeFormatter GetPerRequestFormatterInstance(Type type, HttpRequestMessage request, MediaTypeHeaderValue mediaType)
    {
        return new FormDataMediaTypeFormatter(request);
    }

    public override async Task<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger)
    {
        object instance = Activator.CreateInstance(type);
        PropertyInfo[] props = type.GetProperties();
        string root = HttpContext.Current.Server.MapPath("~/App_Data");      
        if (content.IsFormData())// application/x-www-form-urlencoded
        {
            var formdata = await content.ReadAsFormDataAsync();
            foreach (var prop in props)
            {
                object[] values = formdata.GetValues(prop.Name.ToLower());
                if (values == null || values.Count() == 0) continue;
                object value = values.FirstOrDefault();
                prop.SetValue(instance, value);
            }
                
        }
        else if (content.IsHttpRequestMessageContent())
        {
            return null;
        }
        else if (content.IsHttpResponseMessageContent())
        {
            return null;
        }
        else if (content.IsMimeMultipartContent())// multipart/form-data
        {
            var provider = new MultipartFormDataStreamProvider(root);

            await content.ReadAsMultipartAsync(provider);
            foreach (var prop in props)
            {
                if (prop.PropertyType == typeof(Collection<MultipartFileData>))
                {
                    prop.SetValue(instance, provider.FileData);
                }
                else {
                    object[] values = provider.FormData.GetValues(prop.Name.ToLower());
                    if (values == null || values.Count() == 0) continue;
                    object value = values.FirstOrDefault();
                    prop.SetValue(instance, value);
                }
            } 
        }
        return instance;
    }
}
```

自定义ParameterBindingAttribute ---- FromFormAttribute

```csharp
public class FromFormAttribute : ParameterBindingAttribute
{
    public override HttpParameterBinding GetBinding(HttpParameterDescriptor parameter)
    {
        //HttpConfiguration config = parameter.Configuration;
        //IEnumerable<ValueProviderFactory> valueProviderFactories = GetValueProviderFactories(config);
        //BufferedMediaTypeFormatter
        //parameter.BindWithFormatter()
        if (parameter.ActionDescriptor.SupportedHttpMethods.Contains(HttpMethod.Post))
        {
            // 使用FormDataMediaTypeFormatter来绑定数据
            return parameter.BindWithFormatter(new FormDataMediaTypeFormatter());
            //return new FromFormBinding(parameter);
        }
        throw new NotImplementedException();
    }
}
```

使用：

```csharp
[Route("testfile")]
[HttpPost]
public IHttpActionResult PostFilesTest([FromForm]AudioText file)
{
    var rq = HttpContext.Current;
    return Json(AjaxResult<string>.Success("ok"));
}
```

该接口可以直接把`application/x-www-form-urlencoded` 和 `multipart/form-data` 类型的数据绑定到模型中

`multipart/form-data`格式是针对文件上传的格式，有文件上传的时候，需要给模型添加一个`Collection<MultipartFileData>`类型的属性，用来绑定文件，属性名称随意。

另外，`HttpParameterBinding`、`IValueProvider`和`ValueProviderFactory`类型也是用来自定义模型绑定的



> 文件上传功能发布到服务器时出现异常

可能原因：

* 文件路径问题，路径不存在? 权限问题?

这种看具体情况排查

* 请求报文问题

ReadAsMultipartAsync方法出现异常unexpected end of MIME multi-part stream when uploading from Flex FileReference

这个是web api的一个bug，可能是因为formdata的结尾没有换行符

```
The issue is really simple but extremely hard to fix. The problem is that Uploadify does > not add an "\r\n" at the end of the MultiPartForm message
```

如果出现这种异常,手动给流添加换行

```csharp
Stream reqStream = Request.Content.ReadAsStreamAsync().Result;
MemoryStream tempStream = new MemoryStream();
reqStream.CopyTo(tempStream);



tempStream.Seek(0, SeekOrigin.End);
StreamWriter writer = new StreamWriter(tempStream);
writer.WriteLine();
writer.Flush();
tempStream.Position = 0;


  StreamContent streamContent = new StreamContent(tempStream);
  foreach(var header in Request.Content.Headers)
  {
      streamContent.Headers.Add(header.Key, header.Value);
  }

// Read the form data and return an async task.
  await streamContent.ReadAsMultipartAsync(provider);
```



[文章](https://stackoverflow.com/questions/13770536/asp-net-web-api-unexpected-end-of-mime-multi-part-stream-when-uploading-from-fl)

>文件上传获取文件名小问题

`MultipartFileData`是通过他的header信息获取文件名的，有时候获取到的文件名带有双引号，这时候需要把双引号去掉

```csharp
string filename = file.Headers.ContentDisposition.FileName;
Console.WriteLine(filename);

//输出:
//"图片1.jpg"
```

>web api 开启session功能时，需要登陆两次才能访问到session

问题描述：写了两个接口，一个登录，一个获取登录信息，第一次登录后，获取信息为空，第二次及之后可以获取到登录信息。这个使用httpclient和html+javascript都试过，是一样的结果。

最后从httpclient中能看出来，第一次登录后没有`Set-Cookie` response headers 返回,也就是没有把session_id返回给客户端，第二次登录时才返回给客户端。

web api 配置：

```csharp
public class WebApiApplication : System.Web.HttpApplication
{
    protected void Application_Start()
    {
        GlobalConfiguration.Configure(WebApiConfig.Register);
    }
    public override void Init()
    {
        //注册事件
        this.AuthenticateRequest += WebApiApplication_AuthenticateRequest;
        base.Init();
    }
    void WebApiApplication_AuthenticateRequest(object sender, EventArgs e)
    {
        //启用 webapi 支持session 会话
        HttpContext.Current.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior.Required);
    }
}
```

解决方案：

```csharp
public class WebApiApplication : System.Web.HttpApplication
{
    protected void Application_Start()
    {
        GlobalConfiguration.Configure(WebApiConfig.Register);
    }
    public override void Init()
    {
        //注册事件
        this.AuthenticateRequest += WebApiApplication_AuthenticateRequest;
        base.Init();
    }
    void WebApiApplication_AuthenticateRequest(object sender, EventArgs e)
    {
        //启用 webapi 支持session 会话
        HttpContext.Current.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior.Required);
    }

    void Session_Start(object sender, EventArgs e)
    {
        // your code here, it will be executed upon session start
    }
}
```

加上了个`Session_Start`就莫名其妙好了。

>httpclient 携带cookie

```csharp

public static async Task<ResponData> Login(string userid, string pwd)
{
    ResponData result = null;
    cookie = null;
    int index = 0;
    while ((cookie == null || cookie.Count == 0)&& index<3)
    {
        result = await RetryLogin(userid, pwd);
        index++;
    }
    if (cookie.Count == 0) result.msg = null;
    return result;
}

public static async Task<ResponData> RetryLogin(string userid, string pwd)
{
    UserParameter parameter = new UserParameter
    {
        ID = userid,
        Password = pwd.MD5_32()
    };
    HttpClientHandler handler = GetHandler();
    string url = host + "/api/login/teacher";
    using (HttpClient client = new HttpClient(handler))
    {
        string data = JsonConvert.SerializeObject(parameter);
        var content = new StringContent(data);
        content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
        var respon = await client.PostAsync(url, content);
        var json = await respon.Content.ReadAsStringAsync();
        cookie = handler.CookieContainer.GetCookies(new Uri(host));
        return JsonConvert.DeserializeObject<ResponData>(json);
    }
}


public static HttpClientHandler GetHandler()
{
    HttpClientHandler handler = new HttpClientHandler()
    {
        AllowAutoRedirect = true,
        ClientCertificateOptions = ClientCertificateOption.Automatic,
        UseCookies = true,
        CookieContainer = new CookieContainer()
        
    };
    if (cookie != null)
    {
        handler.CookieContainer.Add(cookie);
    }
    return handler;
}
```

登录的时候，通过`HttpClientHandler`获取cookie信息，存储起来，在每次访问时，再创建`HttpClientHandler`，把cookie放到`HttpClientHandler`中，传递给httpclient;

>httpclient 访问https


需要一个全局配置

```csharp
ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, error) =>
{
    return true;
};
```

然后还是通过`HttpClientHandler`来配置https访问，设置handler的属性

```csharp
HttpClientHandler handler = new HttpClientHandler()
{
    AllowAutoRedirect = true,
    ClientCertificateOptions = ClientCertificateOption.Automatic,
    UseCookies = true,
    CookieContainer = new CookieContainer()
    
};
```

## swagger

>安装 配置

`Nuget` 安装 `Swashbuckle`
```csharp
    public class SwaggerConfig
    {
        public static void Register()
        {
            var thisAssembly = typeof(SwaggerConfig).Assembly;

            GlobalConfiguration.Configuration
                .EnableSwagger(c =>
                    {
                        c.SingleApiVersion("v1", "LASSTS_WebAPI");
                        c.IgnoreObsoleteActions();
                        c.IncludeXmlComments(GlobalConfig.XmlCommentsPath);
                        c.OperationFilter<SwaggerFileUploadFilter>();
                    })
                .EnableSwaggerUi(c =>
                    {
                    });
        }
    }
```

> 注释配置

项目->属性->生成->输出->xml文档文件 中输入 `bin\[项目名称].XML`   
这里默认是debug模式，切换到release模式也配置一样。

生成的xml文件就是整个项目中的类、方法、字段、属性的备注信息。

```csharp
public static string XmlCommentsPath {
    get {
        return Path.Combine(

        AppDomain.CurrentDomain.BaseDirectory,

        "bin",

        string.Format("{0}.XML", typeof(SwaggerConfig).Assembly.GetName().Name));
    }
}


GlobalConfiguration.Configuration
    .EnableSwagger(c =>
        {
            c.IncludeXmlComments(GlobalConfig.XmlCommentsPath);
        })

```

>文件上传/form/formdata 配置

```csharp
public class SwaggerFileUploadFilter : IOperationFilter
{
    public void Apply(Operation operation, SchemaRegistry schemaRegistry, ApiDescription apiDescription)
    {
        if (!apiDescription.HttpMethod.Method.Equals("POST", StringComparison.OrdinalIgnoreCase) &&
        !apiDescription.HttpMethod.Method.Equals("PUT", StringComparison.OrdinalIgnoreCase))
        {
            return;
        }
        var parameters = apiDescription.ParameterDescriptions.Where(m => m.ParameterDescriptor.ParameterBinderAttribute is FromFormAttribute).ToList();
        //var parameters = apiDescription.ParameterDescriptions.Where(n => n.ParameterDescriptor.ParameterType == typeof(MultipartFileData)).ToList();//parameterDescriptions包含了每个接口所带所有参数信息
        if (parameters.Count() <= 0)
        {
            return;
        }
        var formparameters = parameters.FirstOrDefault();
        Type type = formparameters.ParameterDescriptor.ParameterType;

        PropertyInfo[] props = type.GetProperties();

        int fileprop = props.Count(m => m.PropertyType == typeof(Collection<MultipartFileData>));
        if (fileprop > 0)
        {
            operation.consumes.Add("multipart/form-data");
        }
        else {
            operation.consumes.Add("application/x-www-form-urlencoded");
        }

        var rparameter = operation.parameters.Where(m=>m.name == formparameters.Name).FirstOrDefault();
        operation.parameters.Remove(rparameter);
        //operation.parameters.Clear();
        foreach (var prop in props)
        {
            string description = DescriptionHelper.Instance.GetPropertyInfoDescription(type,prop.Name);
            object[] objs = prop.GetCustomAttributes(typeof(DescriptionAttribute), true);
            if (objs.Length > 0)
            {
                description=((DescriptionAttribute)objs[0]).Description;
            }
            if (prop.PropertyType == typeof(Collection<MultipartFileData>))
            {
                operation.parameters.Add(new Parameter
                {
                    name = prop.Name,
                    @in = "formData",
                    description = description,
                    required = true,
                    type = "file"
                    //CollectionFormat = "multi"
                });
            }
            else {
                operation.parameters.Add(new Parameter
                {
                    name = prop.Name,
                    @in = "formData",
                    description = description,
                    required = true,
                    type = "text"
                    //CollectionFormat = "multi"
                });
            }
            
        }
    }
}

public class FromFormAttribute : ParameterBindingAttribute
{
    public override HttpParameterBinding GetBinding(HttpParameterDescriptor parameter)
    {
        //HttpConfiguration config = parameter.Configuration;
        //IEnumerable<ValueProviderFactory> valueProviderFactories = GetValueProviderFactories(config);
        //BufferedMediaTypeFormatter
        //parameter.BindWithFormatter()
        if (parameter.ActionDescriptor.SupportedHttpMethods.Contains(HttpMethod.Post))
        {
            return parameter.BindWithFormatter(new FormDataMediaTypeFormatter());
            //return new FromFormBinding(parameter);
        }
        throw new NotImplementedException();
    }
}

public class FormDataMediaTypeFormatter : MediaTypeFormatter
{
    private readonly HttpRequestMessage _request;

    private const string FORM_DATA = "multipart/form-data";
    private const string FORM_URLENCODE = "application/x-www-form-urlencoded";

    public FormDataMediaTypeFormatter()
    {
        SupportedMediaTypes.Add(new MediaTypeHeaderValue(FORM_DATA));
        SupportedMediaTypes.Add(new MediaTypeHeaderValue(FORM_URLENCODE));
    }

    public FormDataMediaTypeFormatter(HttpRequestMessage request):this()
    {
        _request = request;
    }
    public override bool CanReadType(Type type)
    {
        return true;
    }

    public override bool CanWriteType(Type type)
    {
        return true;
    }

    public override MediaTypeFormatter GetPerRequestFormatterInstance(Type type, HttpRequestMessage request, MediaTypeHeaderValue mediaType)
    {
        return new FormDataMediaTypeFormatter(request);
    }

    public override async Task<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger)
    {
        object instance = Activator.CreateInstance(type);
        PropertyInfo[] props = type.GetProperties();


        string root = HttpContext.Current.Server.MapPath("~/App_Data");
        if (!Directory.Exists(root))
        {
            Directory.CreateDirectory(root);
        }
        
        if (content.IsFormData())// application/x-www-form-urlencoded
        {
            var formdata = await content.ReadAsFormDataAsync();
            foreach (var prop in props)
            {
                object[] values = formdata.GetValues(prop.Name.ToLower());
                if (values == null || values.Count() == 0) continue;
                object value = values.FirstOrDefault();
                prop.SetValue(instance, value);
            }
                
        }
        else if (content.IsHttpRequestMessageContent())
        {
            return null;
        }
        else if (content.IsHttpResponseMessageContent())
        {
            return null;
        }
        else if (content.IsMimeMultipartContent())// multipart/form-data
        {
            var provider = new MultipartFormDataStreamProvider(root);

            await content.ReadAsMultipartAsync(provider);
            foreach (var prop in props)
            {
                if (prop.PropertyType == typeof(Collection<MultipartFileData>))
                {
                    prop.SetValue(instance, provider.FileData);
                }
                else {
                    object[] values = provider.FormData.GetValues(prop.Name.ToLower());
                    if (values == null || values.Count() == 0) continue;
                    object value = values.FirstOrDefault();
                    object setvalue = Convert.ChangeType(value, prop.PropertyType);
                    prop.SetValue(instance, setvalue);
                }
            }
            
        }
        return instance;
    }
}
```

```csharp
GlobalConfiguration.Configuration
    .EnableSwagger(c =>
        {
            c.OperationFilter<SwaggerFileUploadFilter>();
        })
```

当参数使用`[FromForm]`特性时，就用`SwaggerFileUploadFilter`来处理swagger的参数设置。
## 优化

>语料文件访问优化

使用缓存，发现还是比直接浏览器访问文件路径要慢

使用etag和last-modified来对视频信息进行缓存（浏览器缓存）

浏览器发送if-non-match和if-modified-since来访问文件。

流程:
首次访问，没有if-non-match和if-modified-since -> 服务器返回etag和last-modified -> 浏览器访问资源 ->再次访问，包含if-non-match和if-modified-since -> 服务器返回etag和last-modified -> 浏览器接收对比，发现没变化，使用缓存。

没有设置etag时，服务端会返回
```http
Expires: -1 
Pragma: no-cache
```


## 问题
>ui这边由于vue组件协调问题，还有工期问题，放弃使用vue，改用普通的html，这样需要解决跨域问题

```csharp
public class CrocsHandle : DelegatingHandler
{
    protected async override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        var response = await base.SendAsync(request, cancellationToken);
        response.Headers.Add("Access-Control-Allow-Origin", "*");
        response.Headers.Add("Access-Control-Allow-Methods", "POST,GET");
        response.Headers.Add("Access-Control-Allow-Headers", "x-requested-with,content-type");
        return response;
    }
}
```

>跨域cookie问题

当js访问跨域资源时，是不会携带cookie的，使用ajax进行资源访问时，需要配置`withCredentials`
```js
$.ajax({
    type:'POST',
    url:'',
    xhrFields:{
      withCredentials:true,
    },
    crossDomain:true,
    data:{},
    dataType:json,
    success:function(respon){

    }
});
```
配置完成后，才会在跨域访问时给请求头配置上cookie；这时候在服务端还要进行相应配置，`Access-Control-Allow-Origin`的配置不能是`*`，要配置相应的源，告诉浏览器允许那些源来访问这些资源。

webapi：`http:www.example.webapi.com`   
webview：`http:www.example.webview.com`
```csharp
response.Headers.Add("Access-Control-Allow-Origin", "http:www.example.webview.com");

```
>跨域cookie问题2

问题描述：登录成功后，获取不到session信息。

分析：
在登录时手动再设置一个cookie test=test      
使用Filddler拦截请求，发现登录时Response有两个Set-Cookie头

```http
Set-Cookie: ASP.NET_SessionId=z2meli1rsnd0mqeopy0zbhhb; path=/; HttpOnly; SameSite=Lax
Set-Cookie: test=test
```
浏览器收到Set-Cookie后，会把Set-Cookie的内容写入到Cookie中，下次访问时，正常情况下会携带上这两个Cookie    
然后获取登录信息时，发现Request的头中只带有一个Cookie

```
Cookie: test=test
```
ASP.NET_SessionId没有传递到web api中，也就获取不到session     
发现这个现象后，就是要找一下为什么ASP.NET_SessionId没有传递。

之前response返回的Set-Cookie中，ASP.NET_SessionId比test多了两个信息，HttpOnly这个比较常见，还有一个时`SameSite=Lax`，查了下资料，发现正是这个属性限制了跨域cookie的传递。

SameSite=Strict：设置了该属性的cookie将不会添加到跨域请求里。     
SameSite=Lax：设置了该属性的cookie将不会添加到除了GET方法以外的跨域请求里。   

解决方式：登录时，不设置ASP.NET_SessionId的SameSite属性。
```csharp
public class CrocsHandle : DelegatingHandler
{
    protected async override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        var response = await base.SendAsync(request, cancellationToken);
        //response.Headers.Add("Access-Control-Allow-Origin", GlobalConfig.Origin);
        //在复杂跨域请求时会有OPTIONS头发送过来，所以也要加上OPTIONS头
        response.Headers.Add("Access-Control-Allow-Origin", GlobalConfig.Origin);

        response.Headers.Add("Access-Control-Allow-Credentials", "true");
        response.Headers.Add("Access-Control-Allow-Methods", "POST,GET,OPTIONS");
        response.Headers.Add("Access-Control-Allow-Headers", "x-requested-with,content-type");
        if (HttpContext.Current.Response.Cookies.AllKeys.Contains("ASP.NET_SessionId"))
        {
            HttpCookie cookie = HttpContext.Current.Response.Cookies["ASP.NET_SessionId"];
            cookie.SameSite = SameSiteMode.None;
        }
        return response;
    }
}
```
这个只能在.NetFramwork 7.2及以上的版本中能设置，这些版本中SameSite默认时None，所以不设置也可以，但是较低版本中就默认时SameSiteMode.Lax

>跨域问题3

OPTIONS请求头   
一些复杂跨域情况下，会传输OPTIONS请求头，所以后台要运行OPTIONS请求头的请求
```csharp
response.Headers.Add("Access-Control-Allow-Methods", "POST,GET,OPTIONS");
```

>跨域问题4

http访问https api接口时出现异常，chrome控制台显示`provisional headers are shown`

这个调试接口本来是http协议的，但是由于html添加了`<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">`，会把html的的http访问更改为https，所以出现了这个问题

>跨域问题5

options请求问题   
跨域请求分为简单跨域和复杂跨域，复杂跨域时会先发送一个options请求预检，这个预检不应该涉及到业务，所以在CrocsHandle需要判断options请求，如果是options请求，直接返回200状态码
```csharp

public class CrocsHandle : DelegatingHandler
{
    private ILogger logger = LogManager.GetCurrentClassLogger();
    protected async override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        HttpResponseMessage response = null;
        if (request.Method == HttpMethod.Options)
        {
            response = new HttpResponseMessage(System.Net.HttpStatusCode.OK);
        }
        else
        {
            response = await base.SendAsync(request, cancellationToken);
        }
        //response.Headers.Add("Access-Control-Allow-Origin", GlobalConfig.Origin);
        //在复杂跨域请求时会有OPTIONS头发送过来，所以也要加上OPTIONS头
        response.Headers.Add("Access-Control-Allow-Origin", GlobalConfig.Origin);

        response.Headers.Add("Access-Control-Allow-Credentials", "true");
        response.Headers.Add("Access-Control-Allow-Methods", "POST,GET,DELETE,OPTIONS");
        response.Headers.Add("Access-Control-Allow-Headers", "x-requested-with,content-type,Accept,X-PINGOTHER");
        //处理ASP.NET_SessionId的SameSite问题，当SameSite=Lax时，会有跨域限制，也就是跨域除了get情况外都不能懈怠cookie
        //这里Response.Cookies能获取到Set-Cookie信息，找到ASP.NET_SessionId把他的SameSite设置为None
        if (HttpContext.Current.Response.Cookies.AllKeys.Contains("ASP.NET_SessionId"))
        {
            HttpCookie cookie = HttpContext.Current.Response.Cookies["ASP.NET_SessionId"];
            cookie.SameSite = SameSiteMode.None;
        }
        return response;
    }
}
```

>视频播放问题

视频播放要求支持range请求，在response中加上`Accept-Range: bytes`,在调试的时候能用，但是发布到服务器后会出现问题。

解决：
```csharp
if (Request.Headers.Range != null)
{
    HttpResponseMessage partialResponse = Request.CreateResponse(HttpStatusCode.PartialContent);
    partialResponse.Content = new ByteRangeStreamContent(stream, Request.Headers.Range, type, 3 * 1024 * 1024);
    return partialResponse;
}
else {
    HttpResponseMessage fullResponse = new HttpResponseMessage(HttpStatusCode.OK);
    fullResponse.Content = new StreamContent(stream,3 * 1024 * 1024);
    fullResponse.Content.Headers.ContentType = new MediaTypeHeaderValue(type);
    fullResponse.Headers.AcceptRanges.Add("bytes");
    return fullResponse;
}
```
请求到达时，查看请求的Range头，如果没有，直接返回视频信息，给Response加上`Accept-Range: bytes`,如果有Range头，说明是Range请求，返回206，使用`ByteRangeStreamContent`返回内容。



[文章](https://devblogs.microsoft.com/aspnet/asp-net-web-api-and-http-byte-range-support/)

## mongodb问题

>mongodb事务

需求：

* 集群
* 4.0版本及以上

mongodb事务是根据快照来进行回滚的，单机的mongodb是不产生快照(snapshot)的，只有配置了集群，才会产生快照，通过快照来把数据同步到从节点。所以快照是很关键的

```csharp
ReadConcern opread = new ReadConcern(level:ReadConcernLevel.Snapshot);//Snapshot快照
WriteConcern opwriter = new WriteConcern(mode:"majority");//大所数从节点接收到时才确认写入了数据
ClientSessionOptions option = new ClientSessionOptions();
option.DefaultTransactionOptions = new TransactionOptions(readConcern:opread, writeConcern: opwriter);
var session = await client.StartSessionAsync(option);
try
{
    session.StartTransaction();
    dosomething();
    session.CommitTransaction();
}
catch (Exception ex)
{
    await session.AbortTransactionAsync();
}
```

>数组操作问题

在对数组类型push操作时，该字段在MongoDB里不能描述为null，所以在把对象插入collection中时，如果有数组类型的字段，需要初始化，不能为空，否则二次操作push时无法操作。

>lookup问题

>GridFile事务问题

mongodb事务更新需要使用其事务启动时生成的session，但是在GridFile的操作方法中都没有session参数进项传递，所以是没办法进行事务操作。单独操作GridFile时是不用担心事务性的，但是很多情况是更新其他集合的同时需要操作GridFile，这时候需要和其他集合全部操作成功或者回滚，这时候GridFile就没办法实现了

解决方法：自己实现GridFile的更新操作，然后传递session过去

GridFile其实也是使用集合进行操作，由于集合的局限性，导致每条数据有大小限制，所以GridFile是把文件存储到两个集合中，默认是`fs.files`和`fs.chunks`这两个集合

`fs.files`是用来存储文件的基本信息的

```json
_id:ObjectId("5dc522ccdaba21557ca48ea2")

length:87192

chunkSize:261120

uploadDate:2019-11-08T08:09:48.238+00:00

md5:9f9d0a20fbbc9bb8fa43af76714f26dd

filename:"test.txt"
```

`fs.chunks`是用来存储文件内容的，由于合集的局限性，每条数据的大小是有限制的，所以每个文件会存储到多个chunks里，由n进行编号，每个chunks的大小是chunkSize的大小

```json
_id:ObjectId("5df9b7a65212ef1be4d1d4c5")
files_id:ObjectId("5df9b7a65212ef1be4d1d4bc")
n:8
data:Binary('We/hV/eQZXOudgflZk/zbhuE2RUH61fIuE3W0SCfONAO8HnD210qzSgXwhXAl59N59ZATgvzoIdToHe446TWGmtDfPiIuHnunT/T...')
```
chunks的编号`n`是从0开始进行编号的，获取文件时，只要在`fs.files`里获取到文件的基本信息和_id，再根据_id在`fs.chunks`里匹配`files_id`字段，查找chunks，再把多个chunks根据`n`字段进行排序，获取到data，就能够合成文件了。


实现GridFile的可以携带事务session的更新操作
```csharp
    /// <summary>
    /// MongoDB文件替换，需要session，确保替换原子性
    /// </summary>
    public class GridFSBucketReplacer
    {
        private IMongoDatabase Database { get; set; }

        private GridFSBucketOptions Options { get; set; }

        private string fileColName {
            get {
                return Options.BucketName + ".files";
            }
        }

        private string chunkColName {
            get {
                return Options.BucketName + ".chunks";
            }
        }

        public GridFSBucketReplacer(IMongoDatabase database,GridFSBucketOptions options = null)
        {
            this.Database = database;
            if (options == null)
            {
                Options = new GridFSBucketOptions
                {
                    BucketName = "fs",
                    ChunkSizeBytes = 261120
                };
            }
            else {
                Options = options;
            }
        }

        public void Replace(IClientSessionHandle session,ObjectId id,string filename,Stream stream)
        {
            var fileCol = Database.GetCollection<FileInfo>(fileColName);
            var chunkCol = Database.GetCollection<FileChunk>(chunkColName);
            var filequery = Builders<FileInfo>.Filter.Eq("_id", id);
            var file = fileCol.Find(filequery).FirstOrDefault();
            //获取到id
            //更新length，md5，filename
            var fileupdate = Builders<FileInfo>.Update
                .Set("length", stream.Length)
                .Set("filename", filename)
                .Set("chunkSize",Options.ChunkSizeBytes);

            fileCol.UpdateOne(session,filequery, fileupdate);
            //根据id删除原有chunk
            var chunkFilter = Builders<FileChunk>.Filter.Eq("files_id",id);
            chunkCol.DeleteMany(session, chunkFilter);
            //新增chunk
            
            stream.Position = 0;
            int n = 0;
            byte[] buffer = new byte[Options.ChunkSizeBytes];

            int length = stream.Read(buffer, 0, buffer.Length);
            while (length > 0)
            {
                //md5计算
                //chunk插入
                FileChunk chunk = new FileChunk
                {
                    n = n,
                    data = length== Options.ChunkSizeBytes ? buffer:buffer.Take(length).ToArray(),
                    files_id = file._id,
                };
                chunkCol.InsertOne(session,chunk);
                n += 1;
                length = stream.Read(buffer,0,buffer.Length);
            }

        }

        public async Task ReplaceAsync(IClientSessionHandle session, ObjectId id, string filename, Stream stream)
        {
            var fileCol = Database.GetCollection<FileInfo>(fileColName);
            var chunkCol = Database.GetCollection<FileChunk>(chunkColName);
            var filequery = Builders<FileInfo>.Filter.Eq("_id", id);
            var fileCursor =await fileCol.FindAsync(filequery);
            var file = fileCursor.FirstOrDefault();
            if (file == null) throw new Exception("文件不存在");
            //获取到id
            //更新length，md5，filename
            var fileupdate = Builders<FileInfo>.Update
                .Set("length", stream.Length)
                .Set("filename", filename)
                .Set("chunkSize", Options.ChunkSizeBytes);

            await fileCol.UpdateOneAsync(session, filequery, fileupdate);
            //根据id删除原有chunk
            var chunkFilter = Builders<FileChunk>.Filter.Eq("files_id", id);
            await chunkCol.DeleteManyAsync(session, chunkFilter);
            //新增chunk

            stream.Position = 0;
            int n = 0;
            byte[] buffer = new byte[Options.ChunkSizeBytes];

            int length = stream.Read(buffer, 0, buffer.Length);
            while (length > 0)
            {
                //md5计算
                //chunk插入
                FileChunk chunk = new FileChunk
                {
                    n = n,
                    data = length == Options.ChunkSizeBytes ? buffer : buffer.Take(length).ToArray(),
                    files_id = file._id,
                };
                await chunkCol.InsertOneAsync(session, chunk);
                n += 1;
                length = stream.Read(buffer, 0, buffer.Length);
            }
        }

        public void UploadFromStream(IClientSessionHandle session, string filename, Stream stream)
        {
            var fileCol = Database.GetCollection<FileInfo>(fileColName);
            var chunkCol = Database.GetCollection<FileChunk>(chunkColName);
            string md5 = GetStreamMd5(stream);
            //再新增file
            FileInfo file = new FileInfo
            {
                chunkSize = Options.ChunkSizeBytes,
                length = stream.Length,
                filename = filename,
                uploadDate = DateTime.Now,
                md5 = md5
            };

            fileCol.InsertOne(session, file);
            //先添加chunk
            stream.Position = 0;
            int n = 0;
            byte[] buffer = new byte[Options.ChunkSizeBytes];
            int length = stream.Read(buffer, 0, buffer.Length);
            while (length > 0)
            {
                FileChunk chunk = new FileChunk
                {
                    n = n,
                    data = length == Options.ChunkSizeBytes ? buffer : buffer.Take(length).ToArray(),
                    files_id = file._id
                };
                chunkCol.InsertOne(session, chunk);
                n += 1;
                length = stream.Read(buffer, 0, buffer.Length);
            }
        }

        public async Task UploadFromStreamAsync(IClientSessionHandle session, string filename, Stream stream)
        {
            var fileCol = Database.GetCollection<FileInfo>(fileColName);
            var chunkCol = Database.GetCollection<FileChunk>(chunkColName);
            string md5 = GetStreamMd5(stream);
            //再新增file
            FileInfo file = new FileInfo
            {
                chunkSize = Options.ChunkSizeBytes,
                length = stream.Length,
                filename = filename,
                uploadDate = DateTime.Now,
                md5 = md5
            };
            await fileCol.InsertOneAsync(session, file);
            //先添加chunk
            stream.Position = 0;
            int n = 0;
            byte[] buffer = new byte[Options.ChunkSizeBytes];
            int length = stream.Read(buffer, 0, buffer.Length);
            while (length > 0)
            {
                FileChunk chunk = new FileChunk
                {
                    n = n,
                    data = length == Options.ChunkSizeBytes ? buffer : buffer.Take(length).ToArray(),
                    files_id = file._id
                };
                await chunkCol.InsertOneAsync(session, chunk);
                n += 1;
                length = stream.Read(buffer, 0, buffer.Length);
            }
        }

        private string GetStreamMd5(Stream stream)
        {
            MD5 md5 = new MD5CryptoServiceProvider();
            byte[] sec = md5.ComputeHash(stream);
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < sec.Length; i++)
            {
                sb.Append(sec[i].ToString("x2"));
            }
            return sb.ToString();
        }
    }

    internal class FileInfo
    {
        public ObjectId _id { get; set; }
        public long length { get; set; }
        public int chunkSize { get; set; }
        [BsonDateTimeOptions(Kind = DateTimeKind.Local)]
        public DateTime uploadDate { get; set; }
        public string md5 { get; set; }
        public string filename { get; set; }
    }

    internal class FileChunk
    {
        public ObjectId _id { get; set; }
        public ObjectId files_id { get; set; }
        public int n { get; set; }
        public byte[] data { get; set; }
    }
```




## 视频读取问题

视频文件可以边看边读，但是有时候视频信息在视频文件的末尾的时候，视频插件会先把整个文件读取完，获取到视频信息才开始播放。

>mp4 moov

mp4文件是由多个box组合成，其中视频信息存储在moov box中，视频内容实在mdata box中，所以mdata应该几乎是整个文件大小了，如果moov存储在mdata之后，那读取视频信息时需要把整个视频都获取到，这样就比较慢。解决方法就是把moov放在mdata之前。


移除moov信息

`MediaReader`用来获取atom信息
```csharp
public class MediaReader
{
    byte[] commonBuffer = new byte[8];
    byte[] minSizeBuffer = new byte[4];
    byte[] typeBuffer = new byte[4];
    byte[] maxSizeBuffer = new byte[8];

    private Stream stream;
    public MediaReader(Stream stream)
    {
        this.stream = stream;
    }

    public IEnumerable<Atom> GetAtoms()
    {
        return GetAtoms(0,stream.Length);
    }

    public IEnumerable<Atom> GetAtoms(long seek,long length)
    {
        long size = seek + length;
        while (seek < size)
        {
            Atom readAtom = ReadAtom(stream, seek);
            seek += readAtom.Size;
            yield return readAtom;
        }
        if (seek > size)
        {
            throw new Exception("文件异常");
        }
    }

    public byte[] ReadDataWithoutHead(Atom atom)
    {
        byte[] data = new byte[atom.Size - atom.HeadLength];
        stream.Seek(atom.Position + atom.HeadLength,SeekOrigin.Begin);
        stream.Read(data, 0, data.Length);
        return data;
    }

    public byte[] ReadData(Atom atom)
    {
        byte[] data = new byte[atom.Size];
        stream.Seek(atom.Position, SeekOrigin.Begin);
        stream.Read(data, 0, data.Length);
        return data;
    }

    public Atom ReadAtom(Stream stream, long seek)
    {
        
        stream.Seek(seek, SeekOrigin.Begin);
        stream.Read(commonBuffer, 0, 8);
        Array.Copy(commonBuffer, 0, minSizeBuffer, 0, 4);
        Array.Reverse(minSizeBuffer);
        long length = BitConverter.ToUInt32(minSizeBuffer, 0);
        Array.Copy(commonBuffer, 4, typeBuffer, 0, 4);
        string type = Encoding.Default.GetString(typeBuffer);
        bool isFullBox = IsFullBox(type);
        int headLength = isFullBox?12:8;
        //int largeOffset = isFullBox ? 12 : 8;
        if (length == 1)
        {
            stream.Seek(seek + headLength, SeekOrigin.Begin);
            stream.Read(maxSizeBuffer, 0, 8);
            Array.Reverse(maxSizeBuffer);
            length = (long)BitConverter.ToUInt64(maxSizeBuffer, 0);
            headLength += 8;
        }
        else if (length == 0)
        {
            length = stream.Length - seek;
        }
        return new Atom
        {
            Name = type,
            Position = seek,
            Size = length,
            HeadLength = headLength
        };
    }

    /// <summary>
    /// 是否是fullbox，目前只用到了stco和co64两个fullbox，所以简单判断。后续再修改
    /// </summary>
    /// <param name="type"></param>
    /// <returns></returns>
    public bool IsFullBox(string type)
    {
        return type == "stco" || type == "co64";
    }
}
```
`MediaTransformer`用来处理moov信息

```csharp
public class MediaTransformer :IDisposable
{
    public Stream OriginStream;
    public MediaTransformer(string filename)
    {
        OriginStream = File.OpenRead(filename);
    }
    public MediaTransformer(Stream stream)
    {
        OriginStream = stream;
    }

    /// <summary>
    /// 把moov信息移动到视频信息前端
    /// </summary>
    /// <param name="newfile">新文件路径</param>
    /// <returns>true：移动成功，false：moov信息无需移动</returns>
    public bool MoveMoov2Top(string newfile)
    {
        MediaReader reader = new MediaReader(OriginStream);
        List<Atom> atoms = reader.GetAtoms().ToList();
        //判断moov和mdata的位置
        int moovIndex = 0;
        int mdatIndex = 0;
        for (int i = 0; i < atoms.Count; i++)
        {
            Atom atom = atoms[i];
            if (atom.Position < 0 || atom.Size < 0)
            {
                throw new Exception("视频信息异常，视频过大");
            }
            if (atom.Name == "moov")
            {
                moovIndex = i;
            }
            else if (atom.Name == "mdat")
            {
                mdatIndex = i;
            }
        }

        if (moovIndex==0|| mdatIndex == 0)
        {
            throw new Exception("视频信息异常");
        }

        if (moovIndex < mdatIndex)
        {
            return false;
        }


        //移动
        if (atoms[0].Name != "ftyp")
        {
            throw new Exception("视频信息有异常，ftype位置不对");
        }
        Atom moov = atoms[moovIndex];
        for (int i = moovIndex; i> 1; i--)
        {
            atoms[i] = atoms[i - 1];
        }
        atoms[1] = moov;
        //Atom temple = atoms[moovIndex];
        //atoms[moovIndex] = atoms[mdatIndex];
        //atoms[mdatIndex] = temple;

        byte[] moovData = reader.ReadData(moov);

        List<Atom> moovsub = reader.GetAtoms(moov.Position + moov.HeadLength, moov.Size - moov.HeadLength).ToList();

        List<Atom> tracks = moovsub.Where(m => m.Name == "trak").ToList();

        List<Atom> stcos = new List<Atom>();
        byte[] offsetBytes = new byte[4];
        byte[] offset64Bytes = new byte[8];
        foreach (var track in tracks)
        {
            Atom stco = GetStco(reader, track);

            byte[] data = reader.ReadDataWithoutHead(stco);

            byte[] number_of_entries = new byte[4];
            Array.Copy(data, number_of_entries, number_of_entries.Length);
            Array.Reverse(number_of_entries);
            long length = BitConverter.ToUInt32(number_of_entries, 0);
            if (stco.Name == "stco")
            {
                for (long i = 0; i < length; i++)
                {
                    Array.Copy(data, 4 + 4 * i, offsetBytes, 0, offsetBytes.Length);
                    Array.Reverse(offsetBytes);
                    UInt32 offset = BitConverter.ToUInt32(offsetBytes,0);
                    offset += (UInt32)moov.Size;
                    offsetBytes = BitConverter.GetBytes(offset);
                    Array.Reverse(offsetBytes);
                    Array.Copy(offsetBytes, 0, moovData, (stco.Position - moov.Position) + stco.HeadLength + 4 + i* 4, offsetBytes.Length);
                }
            }
            else if (stco.Name == "co64")
            {
                for (long i = 0; i < length; i++)
                {
                    Array.Copy(data, 4 + 8 * i, offset64Bytes, 0, offset64Bytes.Length);
                    Array.Reverse(offset64Bytes);
                    long offset = (long)BitConverter.ToUInt64(offset64Bytes, 0);
                    if (offset < 0) throw new Exception("文件过大");
                    offset += moov.Size;
                    offset64Bytes = BitConverter.GetBytes(offset);
                    Array.Reverse(offset64Bytes);
                    Array.Copy(offset64Bytes, 0, moovData, (stco.Position - moov.Position) + stco.HeadLength + 4 + i * 8, offset64Bytes.Length);
                }
            }
        }

        using (FileStream newStream = File.Create(newfile))
        {
            foreach (Atom atom in atoms)
            {
                byte[] buffer = null;
                if (atom.Name == "moov")
                {
                    buffer = moovData;
                }
                else {
                    buffer = new byte[atom.Size];
                    OriginStream.Seek(atom.Position, SeekOrigin.Begin);
                    OriginStream.Read(buffer, 0, buffer.Length);
                }
                newStream.Write(buffer, 0, buffer.Length);
            }
        }

        return true;

    }

    public Atom GetStco(MediaReader reader,Atom track)
    {
        List<Atom> tracksub = reader.GetAtoms(track.Position + track.HeadLength, track.Size - track.HeadLength).ToList();
        Atom mdia = tracksub.FirstOrDefault(m=>m.Name =="mdia");
        List<Atom> mdiasub = reader.GetAtoms(mdia.Position + mdia.HeadLength, mdia.Size - mdia.HeadLength).ToList();
        Atom minf = mdiasub.FirstOrDefault(m=>m.Name=="minf");
        List<Atom> minfsub = reader.GetAtoms(minf.Position + minf.HeadLength, minf.Size - minf.HeadLength).ToList();
        Atom stbl = minfsub.FirstOrDefault(m=>m.Name=="stbl");
        List<Atom> stblsub = reader.GetAtoms(stbl.Position + stbl.HeadLength, stbl.Size - stbl.HeadLength).ToList();
        Atom stco = stblsub.FirstOrDefault(m => m.Name == "stco" || m.Name == "co64");
        return stco;
    }

    //public bool MoovAtTop(IEnumerable<Atom> atoms)
    //{

    //}

    #region 垃圾回收

    /// <summary>
    /// 释放标记
    /// </summary>
    private bool disposed;
    void IDisposable.Dispose()
    {
        //必须为true
        Dispose(true);
        //通知垃圾回收器不再调用终结器
        GC.SuppressFinalize(this);

    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposed)
        {
            return;
        }
        //清理托管资源
        if (disposing)
        {
            //这里暂时没有托管对象。
        }
        //清理非托管资源 很少用到非托管资源
        OriginStream.Dispose();
        //告诉自己已经被释放
        disposed = true;
    }

    ~MediaTransformer()
    {
        //垃圾回收器只回收托管对象内存，当对象有析构函数时会放入另一个队列，
        //然后在下一次垃圾回收时调用析构函数
        //所以可以在析构函数中处理非托管对象的回收工作。
        //必须为false
        Dispose(false);
    }

    #endregion
}
```

`stco`存储的是chunk的偏移量，当moov移动的时候，数据的存储单位chunk所在位置会有所偏移，所以要做相应修改。
`co64`也是用来存储chunk的偏移量，这个每个存储空间是64位，用于比较大的文件的chunk偏移量存储。
>Range请求头

范围请求，可以用在视频播放，边播放边缓存，也可以用在下载，可以进行断点下载。视频播放一般会有两次及以上请求，一次就是获取视频信息，然后再缓存数据。

>例子

```csharp

[Route("range/{fileid}")]
[HttpGet]
public async Task<HttpResponseMessage> GetRangeFile(string fileid)
{
    Dictionary<string, string> types = new Dictionary<string, string> {
        { ".jpg","image/jpg"},
        { ".png","image/png"},
        { ".mp4","video/mp4"},
        { ".mp3","audio/mp3"},
        { ".docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"},
        { ".docm","application/vnd.openxmlformats-officedocument.wordprocessingml.document"}
    };
    ObjectId id = new ObjectId(fileid);
    var mongoClient = new MongoClient(GlobalConfig.MongoDbConnectStr);
    var database = mongoClient.GetDatabase("test");
    var bucket = new GridFSBucket(database);
    var query = Builders<GridFSFileInfo>.Filter.Eq("_id", id);
    var fileCursor = await bucket.FindAsync(query);
    GridFSFileInfo fileinfo = fileCursor.FirstOrDefault();
    if (fileinfo == null)
    {
        throw new HttpResponseException(HttpStatusCode.NotFound);
    }
    string extension = Path.GetExtension(fileinfo.Filename);
    string type = "application/octet-stream";
    bool hasSuffix = types.TryGetValue(extension, out type);
    type = hasSuffix ? type : "application/octet-stream";
    GridFSDownloadOptions options = new GridFSDownloadOptions
    {
        Seekable = true
    };
    var stream = await bucket.OpenDownloadStreamAsync(id, options);
    if (Request.Headers.Range != null)
    {
        HttpResponseMessage partialResponse = Request.CreateResponse(HttpStatusCode.PartialContent);
        partialResponse.Content = new ByteRangeStreamContent(stream, Request.Headers.Range, type, 3 * 1024 * 1024);
        return partialResponse;
    }
    else
    {
        HttpResponseMessage fullResponse = new HttpResponseMessage(HttpStatusCode.OK);
        fullResponse.Content = new StreamContent(stream, 3 * 1024 * 1024);
        fullResponse.Content.Headers.ContentType = new MediaTypeHeaderValue(type);
        fullResponse.Headers.AcceptRanges.Add("bytes");
        return fullResponse;
    }
}
```

## live server

>代理

live server 来托管静态html，地址为`http://localhost:5500`

真实webapi 地址为`http://192.168.69.143/LASSTSApiTest/api`

代理webapi 地址为 `http://localhost:5500/api`

也就是把所有的请求的webapi地址配置为`http://localhost:5500/api`格式，这样静态html和webapi的域是一样的，也就不存在跨域问题。

```json
  "liveServer.settings.host": "localhost", 
    "liveServer.settings.proxy": {
        "enable": true,
        "baseUri": "/api",
        "proxyUri": "http://192.168.69.143/LASSTSApiTest/api"//测试
    },
    "liveServer.settings.donotVerifyTags": true,
```

代理原理：

live server监听本地5500端口，当前端访问代理webapi地址`http://localhost:5500/api`时，请求会发送到live server，live server会匹配路由，发现有理配置项，从代理配置中获取到webapi的真实`http://192.168.69.143/LASSTSApiTest/api`,把请求的目的地址更改为真实的webapi地址。


