# 常见复杂度排序

Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)

# 时间复杂度

## 求解算法时间复杂度步骤
>找出算法中的基本语句

算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。

>计算基本语句的执行次数的数量级；

只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。

> 用大Ο记号表示算法的时间性能。

将基本语句执行次数的数量级放入大Ο记号中。

如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：

```csharp
for (i=1; i<=n; i++)  
{
    x++;//基本语句
}
       
for (i=1; i<=n; i++)  
{
    for (j=1; j<=n; j++)  
    {
        x++;//基本语句
    }
}
```
第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。

## 示例
> O(1)

常数级，算法执行时间不随n的增长而增长
```
int result=n/2
```
>O(n)

```csharp
int b=0;  
for (i=1;i<=n;i++) 
{    
    b=n;
} 
```

>O(n<sup>2</sup>)

```csharp
int sum=0;
for(i=1;i<=n;i++)
{
    for(j=1;j<=n;j++)
    {
        sum++;//基本语句
    }  
}  
```
```csharp
for (i=1;i<n;i++)  
{   
    y=y+1;             
    for (j=0;j<=(2*n);j++)   
    {
        x++;//基本语句
    }                  
} 
```
基本语句的执行次数为:(n-1)*(2n+1)=2n<sup>2</sup>-n-1    
所以时间复杂度T(n)=O(2n<sup>2</sup>-n-1)=  O(2n<sup>2</sup>)


> O(log<sub>2</sub>n)
```csharp
i=1;      
while (i<=n)
{
    i=i*2; 
}  
```
运行次数x;  
x<sup>2</sup>=n;    
x=log<sub>2</sub>n;     
所以时间复杂度T(n)= O(log<sub>2</sub>n)；

# 空间复杂度

# 常用排序算法的时空间复杂度、

|排序法|平均时间|最差情形|稳定度|额外空间|备注|
|:---|:---|:---|:---|:---|:---|
|冒泡|O(n<sup>2</sup>)|O(n<sup>2</sup>)|稳定|O(1)|n小时较好
|交换|O(n<sup>2</sup>)|O(n<sup>2</sup>)|不稳定|O(1)|n小时较好
|选择|O(n<sup>2</sup>)|O(n<sup>2</sup>)|不稳定|O(1)|n小时较好
|基数|O(log<sub>R</sub>B)|O(log<sub>R</sub>B)|稳定|O(n)|B是真数(0-9) R是基数（个十百）
|Shell|O(nlogn)|O(n<sup>s</sup>) 1<s<2|不稳定|O(1)|s是所选分组
|快速|O(nlogn)|O(n<sup>2</sup>)|不稳定|O(nlogn)|n大时较好
|归并|O(nlogn)|O(nlogn)|稳定|O(1)|n大时较好
|堆|O(nlogn)|O(nlogn)|不稳定|O(1)|n大时较好