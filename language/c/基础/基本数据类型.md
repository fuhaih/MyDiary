# short

二进制存储时，  
1位二进制可以存储的最大值为2^<sup>0</sup>=1;    
2位二进制最大值是11，也就是2^<sup>0</sup>+2^<sup>1</sup>=2^<sup>2</sup>-1=3     
n位二进制的最大值就是2^<sup>0</sup>+....+2^<sup>n-1</sup>=2^<sup>n</sup>-1  
常见cpu的short是16位,所以无符号位的short的取值范围就是0---2<sup>16</sup>-1也就是0---65535

>比较有疑惑的是有符号位的short取值范围  
>取值范围是-2^<sup>15</sup>---2^<sup>15</sup>-1 也就是-32768---32767  

这里需要知道两个概念    
>反码和补码     
>正数的反码：其本身     
>负数的反码：符号位不变，其他各位取反。     
>正数的补码：其本身     
>负数的补码：符号位不变，其他各位取反，加1，也就是其反码加1。       

系统中数值都是以补码的形式来存储的。正数的补码和其二进制形式是一样的，所以      

正数1在系统中存储为00000000 00000001    
而-1在系统中存储为他的补码。    
-1的二进制： 10000000 00000001    
-1的反码:    11111111 11111110   
-1的补码：   11111111 11111111   
所以-1在计算机中存储为 11111111 11111111;   
同理-32787在计算机中存储为10000000 00000001；

负数在计算机中存储范围为    
10000000 00000000 --- 11111111 11111111     
也就是10000000 000000000，-32767 --- -1     
而10000000 00000000并不能表示16位负数的反码，而且与1相加刚好就是-32767，就规定10000000 00000000为-32768的反码       
表示的负数范围是-32768 --- -1

而正数：    
00000000 00000000 --- 01111111 11111111      
表示的范围是0 --- 32767

**思考：**

>为什么用补码来存储负数？

* 方便运算    
拿short类型来说     
-8+9=1 在计算机中可以表示为     

     11111111 11111000  
    +00000000 00001001
    ____________________ 
    100000000 00000001

    由于short只有16位，首位多出来一个1会被寄存器丢弃
    所以计算出来刚好就是00000000 00000001也就是1,
    这个结果和十进制的计算结果是一致的
* 能多表示一位

    使用原码的话10000000 00000000是0的负数形式，也就是-0，该值和0一样，所以使用原码的话，short的表示范围就成了      
    -32767 --- -0,0 --- 32767

>有符号整数和无符号整数相加

>long类型和int类型相加
# 浮点数存储


|类型说明符|比特数|有效数字|数值范围|
|:---|:---|:---|:---|
|fload||||
|double||||
|long double||||

