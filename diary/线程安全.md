# 术语
|术语|英文单词|描述|
|:-|:-|:-|
|共享内存|shared memory|进程在启动时会分配内存，不同进程间分配的内存是不能互相访问的（A进程不能访问B进程的内存），而共享内存就是能多个进程一起使用的内存空间，是进程间通信的一种方式。
|共享变量||在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。
|内存屏障|Memory Barriers|是一组处理器指令，用于实现对内存操作的顺序限制。
|缓冲行|Cache line|缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。
|原子操作|Atomic operations|不可中断的一个或一系列操作。
|缓存行填充|cache line fill|当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3的或所有）
|缓存命中|cache hit|如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存。
|写命中|write hit|当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。
|写缺失|write misses the cache|一个有效的缓存行被写入到不存在的内存区域。
# [volatile](http://www.infoq.com/cn/articles/ftf-java-volatile#anch89359)

## 实现原理
|||
|:-|:-|
|Java代码：|instance = new Singleton();//instance是volatile变量|
|汇编代码：|0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp)|

有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。

* 将当前处理器缓存行的数据会写回到系统内存。(会锁定缓存或者总线，确保修改的原子性，锁总线开销较大，这个要看处理器架构)  
* 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。

## 原子性、可见性、有序性
volatile修饰符只保证可见性和有序性，不能保证原子性

* 可见性: lock前缀使得修改后的数据在写入系统内存时，其他处理器的缓存失效，所以处理器每次获取到的数据都是最新的数据
* 有序性： lock前缀锁定这块内存区域的缓存（或者总线）并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。

不加volatile的情况下：  
获取数据的时候，有可能获取到的是缓存的数据，而不是最新的存入到内存中的数据，而且数据修改的时候，也不会立刻把修改后的新数据写入系统内存（没有可见性），所以当多个处理器同时修改的时候，不能确保先修改的数据先写入到系统内存（没有有序性）

## Volatile的使用优化
著名的Java并发编程大师Doug lea在JDK7的并发包里新增一个队列集合类LinkedTransferQueue，他在使用Volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。

追加字节能优化性能？这种方式看起来很神奇，但如果深入理解处理器架构就能理解其中的奥秘。让我们先来看看LinkedTransferQueue这个类，它使用一个内部类类型来定义队列的头队列（Head）和尾节点（tail），而这个内部类PaddedAtomicReference相对于父类AtomicReference只做了一件事情，就将共享变量追加到64字节。我们可以来计算下，一个对象的引用占4个字节，它追加了15个变量共占60个字节，再加上父类的Value变量，一共64个字节。

为什么追加64字节能够提高并发编程的效率呢？ 因为对于英特尔酷睿i7，酷睿， Atom和NetBurst， Core Solo和Pentium M处理器的L1，L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头尾节点，当一个处理器试图修改头接点时会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作是需要不停修改头接点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头接点和尾节点加载到同一个缓存行，使得头尾节点在修改时不会互相锁定。

那么是不是在使用Volatile变量时都应该追加到64字节呢？不是的。在两种场景下不应该使用这种方式。第一：缓存行非64字节宽的处理器，如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽。第二：共享变量不会被频繁的写。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，共享变量如果不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。

## 适用场景
1）对变量的写操作不依赖于当前值     
2）该变量没有包含在具有其他变量的不变式中   
第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性


能想到的有队列

# Interlocked
## c#类方法
|方法|功能|
|:-|:-|
|Add|以原子操作的形式，添加两个整数并用两者的和替换第一个整数
|CompareExchange|比较两个值是否相等，如果相等，则替换其中一个值。
|Decrement|以原子操作的形式递减指定变量的值并存储结果。
|Exchange|以原子操作的形式将变量设置为指定的值。
|Increment|以原子操作的形式递增指定变量的值并存储结果。

## 内存对齐

# SpinWait
# 线程安全类
# 锁（包括 Monitor，lock，ReaderWriterLockSlim，闭锁，自旋锁）
# CAS

对于细粒度操作，除了volatile提供的轻量级的同步机制，还有另外一种更高效的乐观方法。
在针对多处理器操作而设计的处理器中提供了一些特殊指令，用于管理对共享数据的并发访问。
现在，几乎所有的现代处理器中都包含了某种形式的原子读-改-写指令，例如比较并交换(compare and swap)、关联加载/条件存储(load linked/store conditional)。操作系统和JVM使用这些指令来实现锁和并发的数据结构。
## 锁和Interlocked的原理有什么不同
# 信号量
# 栅栏（Task.WaitAll）
# 线程池和task
# 消费者生产者模式