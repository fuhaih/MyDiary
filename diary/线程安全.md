# [volatile](http://www.infoq.com/cn/articles/ftf-java-volatile#anch89359)

## 实现原理
|||
|:-|:-|
|Java代码：|instance = new Singleton();//instance是volatile变量|
|汇编代码：|0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);
有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码，通过查IA-32架构软件开发者手册可知，lock前缀的指令在多核处理器下会引发了两件事情。

* 将当前处理器缓存行的数据会写回到系统内存。(会锁定缓存或者总线，确保修改的原子性，锁总线开销较大，这个要看处理器架构)  
* 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。

## 原子性、可见性、有序性
volatile修饰符只保证可见性和有序性，不能保证原子性

* 可见性: lock前缀使得修改后的数据在写入系统内存时，其他处理器的缓存失效，所以处理器每次获取到的数据都是最新的数据
* 有序性： lock前缀锁定这块内存区域的缓存（或者总线）并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。

不加volatile的情况下：  
获取数据的时候，有可能获取到的是缓存的数据，而不是最新的存入到内存中的数据，而且数据修改的时候，也不会立刻把修改后的新数据写入系统内存（没有可见性），所以当多个处理器同时修改的时候，不能确保先修改的数据先写入到系统内存（没有有序性）

## Volatile的使用优化


## 适用场景
1）对变量的写操作不依赖于当前值     
2）该变量没有包含在具有其他变量的不变式中   
第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性

能想到的有队列

# Interlocked

计数器的指令操作分为三部分（读取、修改、写入）
# 线程安全类
# 锁（包括 Monitor，lock，ReaderWriterLockSlim，闭锁）
# 信号量
# 栅栏（Task.WaitAll）
# 线程池和task